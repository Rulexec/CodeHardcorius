Рекурсия
<p>Рекурсией называется метод, когда функция вызывает саму себя. В прошлой заметке мы находили N-ое число Фибоначчи при помощи цикла. Теперь найдём при помощи рекурсии:</p>
<pre><code data-language='c++'># encoding: utf-8

def fibonacci(N):
    if N &lt;= 2:
        return 1
    else:
        return fibonacci(N - 1) + fibonacci(N - 2)

a = fibonacci(3)
b = fibonacci(5)
c = fibonacci(7)

print(a, b, c)</code></pre>
<p>Получилось несколько чуть более компактнее и проще, возможно. Дело в том, что числа Фибоначчи можно определить следующим образом:</p>
<pre>f(1) = 1
f(2) = 1
f(3) = f(2) + f(1) = 2
f(4) = f(3) + f(2) = 3
f(5) = f(4) + f(3) = 5
...</pre>
<p>Видите закономерность? Результат функции можно представить как сумму результатов функций с аргументом на единицу и на двойку меньше, чем текущий. Ну и первые два элемента определены изначально.</p>
<p>Что мы и сделали в коде. Однако этот вариант хоть и более «по-математически», он обладает существенными недостатками с решением используя циклы. Во-первых мы дважды выполняем функцию, что не эффективно, т.к. мы лишний раз пересчитываем весь ряд целиком (при этом не просто в два раза, а даже больше, потому что оно каждый раз ещё разветвляется). Во-вторых вызов функции не бесплатен, каждый вызов функции 
то создание в стеке (позже о нём) дополнительной «переменной», которая указывает на место программы, где мы вызывали эту функцию (чтобы знать, куда вернуться, когда она выполнится).</p>
<p>Впрочем, мы можем решить некоторые из этих проблем. Но всё равно, если это возможно — не используйте рекурсию там, где можно обойтись без неё, не жертвуя удобством.</p>
