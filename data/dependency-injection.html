Dependency injection
<p>По-русски это звучит как «внедрение зависимости». Суть в том, что когда мы создаём объекты — после создания мы «внедряем» в него объекты, которые реализуют эти самые «зависимости».</p>
<p>Реализуется это крайне просто: классы имеют поля, типа <a href='#object-interface'>интерфейс</a>, а так методы, которые позволяют присваивать им ссылки на объекты, реализующие эти интерфейсы.</p>
<p>Выгода следует из того, что мы можем иметь различные реализации каких-то частей системы и передавая их в объекты, которые используют эти части (т.е. зависимы от них) можем менять поведение системы изменяя только модули, которые мы хотим изменить и никакие другие больше.</p>
<p>Например, у нас есть объект для сбора неких событий, которые происходят (ведение лога). Мы можем выделить зависимость <i>«хранилище»</i> или около того. Сделаем для неё интерфейс <b>IStorage</b>, имеющий метод <b>store</b>, принимающий строку.</p>
<p>А затем мы можем создать две реализации этого интерфейса. Один класс будет выводить пришедшую строку на экран, а второй записывать в файл.</p>
<p>Так же добавим классу нашего логгера метод <b>setStorage</b> принимающий объект реализующий <b>IStorage</b> и присвоим его какому-нибудь полю. Когда событие происходит — преобразуем его в строку и вызываем метод <b>store</b> объекта, который записан в этом поле. В зависимости от того, экземпляр какого класса мы «внедрили» в наш логгер он будет или выводить строку на экран или записывать её в файл.</p>
<p>Это и есть внедрение зависимостей.</p>
<p>Мы можем создать какой-либо конфиг, в котором можно выбрать, нужно писать в файл или выводить на экран. И в зависимости от него создавать соответсвующий объект и передавать его в логгер. И, например, при разработке выводить на экран, потому что так проще за этим наблюдать, а в продакшене — писать в файл, чтобы можно было посмотреть потом историю за прошлый день, к примеру.</p>
