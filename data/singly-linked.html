Односвязный список
<p>Итак, сейчас я попытаюсь объяснить, как устроен и для чего требуется односвязный список. Как я сказал в прошлой заметке — список может содержать произвольное количество элементов. Это достигается следующим образом: создаётся <a href='#struct'>структура</a> имеющая два поля, поле для данных и указатель типа такой структуры.</p>
<p>Изначально мы имеем лишь NULL-указатель (указатель, который указывает на нулевой байт памяти, а т.к. он занят операционной системой и заведомо не может быть занят программой, считывается, что он никуда не указывает). Это значит, что в нашем списке нет элементов. Затем, когда нам нужно добавить в него элемент, мы выделяем память под структуру элемента списка, записываем в неё данные, которые мы хотим сохранить и присваиваем нашему указателю адрес созданной структуры.</p>
<p>Теперь у нас есть указатель, указывающий на структуру с данными нашего первого элемента. Добавим ещё один элемент. Снова создаём структуру, записываем в неё данные. В указатель (который хранится в структуре) записываем значение указателя, который указывает на начало списка. И присваиваем этому указателю адрес на только что созданную структуру.</p>
<p>Немного непонятно объяснил, возможно, поясню. Чтобы добавить новый элемент в начало нашего списка мы создаём структуру, делаем так, чтобы у неё был указатель на следующую структуру (т.е. на ту, на которую в данный момент указывает наш указатель), заменяем значение указателя на адрес только что созданной структуры.</p>
<p>То есть список, по сути — это указатель на первый элемент списка и указатели на следующий элемент у каждого из них. Получается такая «цепочка» элементов. Именно поэтому для того, как я говорил, чтобы получить элемент к определённому элементу списка нам нужно «пройтись» по всем предыдущим. Потому что мы не имеем адреса конкретного элемента, всё что у нас есть — адрес первого из них. И нам нужно за эту «ниточку» вытягивать все остальные, чтобы получить тот, который нам нужен.</p>
<p>Реализую этот список на C++:</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

struct ListElement {
    int data;
    ListElement *next;
};

void addElement(ListElement **list, int x) {
    ListElement *el = new ListElement(); // Создаём структуру для нового элемента
    el-&gt;data = x; // Сохраняем данные
    el-&gt;next = *list; // Делаем чтобы новая структура указывала на старую первую
    *list = el; // Делаем первым элементом только что созданную структуру
}

int main(int argc, char *argv[]) {

    ListElement *head = NULL;

    addElement(&amp;head, 49);
    addElement(&amp;head, 30);
    addElement(&amp;head, 86);
    addElement(&amp;head, -3);
    addElement(&amp;head, 12);

    ListElement *el = head;
    while (el != NULL) {
        std::cout &lt;&lt; el-&gt;data &lt;&lt; ' ';
        el = el-&gt;next;
    }

    std::cout &lt;&lt; std::endl;

}</code></pre>
<p>Вывод у программы такой:</p>
<pre>12 -3 86 30 49</pre>
<p>Заметьте, что т.к. мы добавляем элементы в начало списка, то первым будет идти тот, который добавили последним, а последним тот, который добавляли первым.</p>
<p>Чтобы добавить элемент в конец списка мы должны пройтись по им всем, чтобы найти последний (который будет указывать на NULL), создать новую структуру и сделать так, чтобы старый последний (который мы нашли) указывал не на NULL, а на созданный элемент. Поэтому кажется логичным, что мы можем пожертвовать 4 или 8 байтами на указатель на последний элемент и не искать его каждый раз.</p>
<p>Удалять из списка элементы не сильно сложнее, чем добавлять. Нужно просто взять элемент, который следует перед тем, который мы ходим удалить и элемент после. Затем сделать так, чтобы элемент перед стал указывать на элемент после. И освободить память, занятую элементом, который мы удаляем.</p>
