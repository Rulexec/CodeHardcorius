Указатель
<p>Относительно сложная тема, но, надесь, мы справимся. Указатели обычно имеются лишь в «низкоуровневых» языках, где предоставлен прямой доступ к памяти. Назначение указателей, как ни странно — указывать на значение какой-либо переменной.</p>
<p>Указатель, на самом деле, это переменная специального типа, которая хранит обычно 32 или 64-битное (в зависимости от битности операционной системы) целое число, которое является адресом в памяти той переменной, на которую мы указываем.</p>
<p>Так же существуют операторы взятия адреса от переменной и оператор «разыменовывания», который позволяет по адресу получить значение переменной, которая находится по этому адресу.</p>
<p>К примеру, мы можем создать некую переменную <b>A</b> и указатель на неё <b>B</b>. Например, значение переменной <b>A</b> находится по адресу <b>1334</b> и оно равно <b>777</b>, а значение указателя находится по адресу <b>2048</b>. Т.е. в памяти по адресу <b>1334</b> хранится значение <b>777</b>. А по адресу <b>2048</b> находится значение <b>1334</b>.</p>
<p>Выглядит немного запутанно, да. Давайте посмотрим пример:</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

int main(int argc, char *argv[]) {

    int A = 777;
    int *B = &amp;A;

    std::cout &lt;&lt; "A value: " &lt;&lt; A &lt;&lt; ". A address: " &lt;&lt; &amp;A &lt;&lt; std::endl;
    std::cout &lt;&lt; "B value: " &lt;&lt; B &lt;&lt; ". B address: " &lt;&lt; &amp;B &lt;&lt; std::endl;
    std::cout &lt;&lt; "*B value: " &lt;&lt; *B &lt;&lt; std::endl;

}</code></pre>
<p>Данная программа у меня выводит что-то вроде:</p>
<pre>A value: 777. A address: 0x7fffe4aed624
B value: 0x7fffe4aed624. B address: 0x7fffe4aed628
*B value: 777</pre>
<p>Эти большие числа и есть адреса (они в 16-ричной записи). Как вы видите, указатель просто хранит адрес переменной, на которую он указывает и позволяет получить доступ к значению по этому адресу. Обратите внимание, что при каждом запуске программы они будут различны. Это связано с тем, что система выделяет под переменные каждый раз другой кусочек памяти, потому что другие программы могли занять предыдущий между запусками, например.</p>
<p>Так же, если мы изменим значение A, либо *B, то значение в *B, либо в A соответственно так же изменится, потому что на самом деле оно там не хранится, а указатель лишь указывает на истинное местонахождение значения.</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

int main(int argc, char *argv[]) {

    int A = 777;
    int *B = &amp;A;

    std::cout &lt;&lt; "A value: " &lt;&lt; A &lt;&lt; ". A address: " &lt;&lt; &amp;A &lt;&lt; std::endl;
    std::cout &lt;&lt; "*B value: " &lt;&lt; *B &lt;&lt; ". B value: " &lt;&lt; B &lt;&lt; ". B address: " &lt;&lt; &amp;B &lt;&lt; std::endl;

    A = 12;
    std::cout &lt;&lt; std::endl &lt;&lt; "A now is 12." &lt;&lt; std::endl &lt;&lt; std::endl;

    std::cout &lt;&lt; "A value: " &lt;&lt; A &lt;&lt; ". A address: " &lt;&lt; &amp;A &lt;&lt; std::endl;
    std::cout &lt;&lt; "*B value: " &lt;&lt; *B &lt;&lt; ". B value: " &lt;&lt; B &lt;&lt; ". B address: " &lt;&lt; &amp;B &lt;&lt; std::endl;

    *B = 4;
    std::cout &lt;&lt; std::endl &lt;&lt; "*B now is 4." &lt;&lt; std::endl &lt;&lt; std::endl;

    std::cout &lt;&lt; "A value: " &lt;&lt; A &lt;&lt; ". A address: " &lt;&lt; &amp;A &lt;&lt; std::endl;
    std::cout &lt;&lt; "*B value: " &lt;&lt; *B &lt;&lt; ". B value: " &lt;&lt; B &lt;&lt; ". B address: " &lt;&lt; &amp;B &lt;&lt; std::endl;

}</code></pre>
<p>Вывод данной программы получился следующим:</p>
<pre>A value: 777. A address: 0x7fffeca117c4
*B value: 777. B value: 0x7fffeca117c4. B address: 0x7fffeca117c8

A now is 12.

A value: 12. A address: 0x7fffeca117c4
*B value: 12. B value: 0x7fffeca117c4. B address: 0x7fffeca117c8

*B now is 4.

A value: 4. A address: 0x7fffeca117c4
*B value: 4. B value: 0x7fffeca117c4. B address: 0x7fffeca117c8</pre>
<p>Как видите, значение переменной меняется вместе с значением разыменованного указателя и наоборот.</p>
<p>Так же возможны более сложные варианты, вроде создания указателя на указатель. Мы можем создать указатель, который указывает на указатель. В таком случае для доступа к значению, на которое указывает указатель, на который мы указываем нужно дважды его разыменовать.</p>
<p>Смысл использования указателей и указателей на указателей я сейчас попробую объяснить. Указатели используются для трёх целей, в основном:</p>
<ul>
  <li>Выделение памяти не на стеке, а в куче (об этом позже).</li>
  <li>Массивы.</li>
  <li>Передача ссылок на значение в функцию, чтобы она могла его изменить в процессе выполнения.</li>
</ul>
<p>Начнём с массивов, потому что мы о них хоть что-то знаем. Как я сказал, массив это определённое количество элементов одного типа, к которым есть доступ по индексу. Как это организовано. Допустим, у нас есть массив из 32-битных чисел, размером в 10 элементов. Т.е. он должен занимать 40 байт, непрерывно.</p>
<p>Переменная, через которую мы работаем с массивом и которая его представляет на самом деле является указателем на первый его элемент. И так как значение указателя (адрес, где размещается этот первый элемент) это просто число и мы знаем, сколько байт занимает каждый элемент, мы можем нехитрыми действиями вычислить адрес, по которому располагается определённый элемент массива. Давайте посмотрим пример.</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

int main(int argc, char *argv[]) {

    int array[3] = {10, 20, 30};

    std::cout &lt;&lt; array[0] &lt;&lt; ' ';
    std::cout &lt;&lt; array[1] &lt;&lt; ' ';
    std::cout &lt;&lt; array[2] &lt;&lt; std::endl;

    int *p = array;

    std::cout &lt;&lt; *(p + 0) &lt;&lt; ' ';
    std::cout &lt;&lt; *(p + 1) &lt;&lt; ' ';
    std::cout &lt;&lt; *(p + 2) &lt;&lt; std::endl;

}</code></pre>
<p>Здесь мы просто создали массив из трёх элементов: 10, 20 и 30. Вывели его. Затем создали указатель, которому присвоили значение массива (обратите внимание, что не пришлось даже адрес брать, как с обычной переменной). И вывели значение, которое получается при разыменовывании указателя плюс смещение (мы не умножали его на размер int'а потому что C++ автоматически делает это за нас и если мы прибавим к указателю, который указывает на переменную типа int, например, 15, то это будет смещение, эквивалентное 15 int'ам).</p>
<p>Относительно непонятных стеков и куч. Дело в том, что значения переменных, которые вы объявляете, хранятся в неком <a href='#stack'>стеке</a>, который находится в оперативной памяти. Программа, например, может где-то у себя внутри запоминать, сколько переменных в стеке она создала и при выходе из функции очистить столько верхних элементов стека. Либо же иметь какие-либо более совершенные методы. Но суть в том, что этот стек ограничен и не может хранить очень большое количество данных. И, например, создать массив в миллион элементов может не получиться.</p>
<p>Поэтому можно вызовом специальной функции попросить у операционной системы себе какой-то кусок оперативной памяти. Этот метод вернёт нам его адрес и мы сможем с ним работать, записывать туда что-то и так далее. И самое главное, что в стеке находится лишь значение указателя на этот наш удалённый «островок».</p>
<p>Указатели, вообще, довольно сложно понять, к тому же я вижу, что плохо объясняю. Но перейдём к последнему. Мы знаем, что функции принимают аргументы и могут работать с ними. Однако посмотрите на этот пример:</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

// Тип void значит, что функция ничего не возвращает
void addFive(int a) {
    a += 5;
}

int main(int argc, char *argv[]) {

    int a = 5;

    addFive(a);

    std::cout &lt;&lt; a &lt;&lt; std::endl;

}</code></pre>
<p>Думаете будет выведено 10? Нет. Дело в том, что в функцию передаются значения, а не «сами переменные». Т.е. в функции будет копия переменной, а не она сама. Чтобы иметь возможность изменять значение переменной нужно передать указатель на неё:</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

void addFive(int *a) {
    // Получаем доступ к значению разыменовывая указатель
    // и прибавляем к нему пятёрку
    *a += 5;
}

int main(int argc, char *argv[]) {
    int a = 5;

    addFive(&amp;a); // Берём адрес от a и передаём его в функцию

    std::cout &lt;&lt; a &lt;&lt; std::endl;

}</code></pre>
<p>Вот, результат этой программы будет уже 10. Потому что передавши адрес, нам всё равно, копия это или нет, мы можем его разыменовать и получить доступ к значению.</p>
<p>Однако представим, что у нас есть указатель и мы хотим в функции изменить на что он будет указывать. Здесь то же самое. Нам передаётся <b>значение</b> указателя, лишь копия. Чтобы изменить его, нам нужно передать в функцию... указатель на указатель. Теперь понимаете, для чего они нужны?</p>
