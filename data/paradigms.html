Парадигмы
<p>В программировании существует такое понятие как парадигмы. Это понятие довольно абстрактное, я не могу его чётко сформулировать, приведу примеры.</p>
<p>Изначально, как я понимаю, существовали большущие «схемы», размером в комнату и больше. И программирование сводилось к тому, чтобы переключать некие тумблеры в определённых местах, либо соединять разные контакты шнурами (на самом деле я вообще ничего не знаю об этом и просто предполагаю). Такое программирование мы можем назвать шнуро-ориентированным, например.</p>
<p>Через много лет появились микросхемы, представляющие из себя <a href='#black-box'>чёрные ящики</a>, у которых есть входы и выходы (ножки), на которые следует в определённом порядке подавать ток, чтобы записать туда некий <a href='#algorhytm'>алгоритм</a> и затем тоже в некотором порядке можно подавать ток на другие ножки, чтобы вводить туда данные и алгоритм выполнялся. Ну и так же на некоторых ножках может появляться ток, что мы должны обрабатывать и тоже что-то делать.</p>
<p>Ну и люди сделали устройства, которые позволяют брать некий текст и преобразовывать в эту необходимую последовательность подачи электричества на ножки микросхем. Сначала этот текст представлял «сырой» код, называемый машинным. Т.е. у каждой схемы существовала документация, какие числа (числа могут быть представлены в виде последовательности подачи электричества, или более хитрыми способами) будучи переданными в микросхему что будут делать.</p>
<p>В машинном коде было сложно программировать, поскольку он был похож просто на мешанину цифр (ну и букв, если записано в шеснадцатеричной форме). Поэтому изобрели ассемблер (множество их), который представлял лишь мнемонические синонимы для машинных команд. Т.е. например, команда <b>mov</b>, которая вроде как записывает значение с одного адреса в другой будет преобразована в какое-нибудь число.</p>
<p>На этом этапе возможно существовали какие-либо парадигмы, но код был в виде большого длинного списка различных команд. На этом программировать так же было затруднительно.</p>
<p>Придумали различные языки, которые являлись более «высокими», чем ассемблер, плюс позволяли компилировать программы написанные на этих языках в разные языки ассемблера, чтобы запускаться на различных устройствах. В этом момент появилось структурно-ориентированное программирование. Появились функции и процедуры (в ассемблере они так же по сути были, но «не так явно»).</p>
<p>Теперь код преставлял из себя функции, процедуры, принимающие различные аргументы и возвращающие результат. Каждая из функций/процедур могла быть использована множество раз в различных проектах, но с этим всё равно были проблемы. Кто-то сказал, что когда кода становится очень много, функций становится ещё больше и начинаются проблемы, потому что... потому что.</p>
