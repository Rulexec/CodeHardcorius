<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <title>Code Hardcorius</title>

  <meta name='description' content='Code Hardcorius v0.9.0 — как не научиться программировать.'>
  <meta name='keywords' content='программирование'>
  <meta name='author' content='Александр Рулёв'>

  <script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js'></script>

  <script src='rainbow.min.js'></script>
  <link href='github.css' rel='stylesheet' media='screen'>

  <link href='http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css' rel='stylesheet' media='screen'>

  <script>
$(function() {
    $('a').each(function(){
        var hash = this.hash;
        var a = $(this);
        if (hash && !document.getElementById(hash.slice(1))) {
            a.addClass('muted');
            a.click(function() {
                return false;
            });
        };
    });

    var transition = false;
    var state = false;
    $('#content-button').click(function() {
        if (transition) return;

        transition = true;
        $('#content-block').animate({right: (state ? '-300px' : '0px')}, 500, 'swing',
        function() {
            transition = false;
            state = !state;
            $('#content-button i'
            ).removeClass('icon-arrow-' + (state ? 'left' : 'right')
            ).addClass('icon-arrow-' + (state ? 'right' : 'left'));
        });
    });
});
  </script>

  <style>
#items li, p {
    font-size: 1.3em;
    font-family: serif;
    line-height: 1.3em;
    margin: 1em 0;
}
#items li {
    margin: 0.3em 0;
}
#content-block {
    position: fixed;
    height: 100%;
    top: 0px;
    right: -300px;
}
#content {
    width: 300px;
    height: 100%;
    position: absolute;
    top: 0px;
    right: 0px;
    background: white;
    z-index: 4;
    box-shadow: 0px 0px 5px 1px rgba(0, 0, 0, 0.25);
    overflow-y: auto;
    overflow-x: hidden;
}
#content-button {
    width: 30px;
    height: 50px;
    position: absolute;
    top: calc(50% - 25px);
    right: 300px;
    background: white;
    z-index: 5;
    box-shadow: -3px 0px 5px -2px rgba(0, 0, 0, 0.25);
    border-radius: 5px 0px 0px 5px;
    cursor: pointer;
}
#content-button i {
    margin: 0px;
    position: relative;
    top: 16px;
    left: 8px;
    opacity: 0.75;
}
  </style>
</head>

<body><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter21337681 = new Ya.Metrika({id:21337681, clickmap:true, trackLinks:true, accurateTrackBounce:true}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="//mc.yandex.ru/watch/21337681" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter -->
<div id='content-block'>
  <div id='content'>
    <div style='padding: 10px 0px 0px 20px;'>
      <h4>Содержание</h4>
      <ul class='unstyled'>
<li><a href='#introduction'>Предисловие</a></li><li><a href='#algorhytm'>Алгоритм</a><ul><li><a href='#if'>Условие</a></li><li><a href='#loop'>Цикл</a><ul><li><a href='#while'>while</a></li><li><a href='#do-while'>do while</a></li><li><a href='#for'>for</a></li></ul></li></ul></li><li><a href='#back'>Фундаментальное <span class='muted'>(?)</span></a><ul><li><a href='#variable'>Переменная</a></li><li><a href='#array'>Массив</a></li><li><a href='#function'>Функция</a><ul><li><a href='#recursion'>Рекурсия</a></li></ul></li><li><a href='#pointer'>Указатель</a></li><li><a href='#struct'>Структура</a></li></ul></li><li><a href='#concepts'>Концепции</a><ul><li><a href='#black-box'>Чёрный ящик</a></li><li><a href='#state'>Состояние</a></li><li><a href='#interface-concept'>Интерфейс</a></li></ul></li><li><a href='#abstract'>Абстрактные типы данных</a><ul><li><a href='#list'>Список</a><ul><li><a href='#singly-linked'>Односвязный список</a></li><li><a href='#doubly-linked'>Двусвязный список</a></li></ul></li><li><a href='#stack'>Стек</a></li><li><a href='#queue'>Очередь</a></li><li><a href='#hashtable'>Хеш-таблица</a><ul><li><a href='#hashmap'>HashMap</a></li><li><a href='#hashset'>HashSet</a></li></ul></li><li><a href='#tree'>Дерево</a></li></ul></li><li><a href='#paradigms'>Парадигмы</a><ul><li><a href='#OOP'>ООП</a></li><li><a href='#FP'>Функциональное программирование</a></li></ul></li><li><a href='#OOProgramming'>Объектно-ориентированное программирование</a><ul><li><a href='#object'>Объект</a></li><li><a href='#class'>Класс</a></li><li><a href='#inheritance'>Наследование</a></li><li><a href='#object-interface'>Интерфейс</a></li><li><a href='#polymorphism'>Полиморфизм</a></li></ul></li><li><a href='#architecture'>Архитектура</a><ul><li><a href='#incapsulation'>Инкапсуляция</a></li><li><a href='#patterns'>Паттерны</a><ul><li><a href='#dependency-injection'>Dependency injection</a></li><li><a href='#pubsub'>PubSub</a></li><li><a href='#mvc'>MVC</a></li></ul></li><li><a href='#antipatterns'>Антипаттерны</a></li></ul></li><li><a href='#security'>Безопасность</a><ul><li><a href='#input-data'>Входные данные</a></li></ul></li><li><a href='#complexity'>Сложность алгоритма</a></li><li><a href='#end'>Заключение</a></li>
      </ul>
    </div>
  </div>
  <div id='content-button'><i class='icon-arrow-left'></i></div>
</div>

<div class='container-fluid'>
  <div class='row-fluid'>
    <div class='span8 offset2'>
      <div class='page-header'>
        <h1>Code Hardcorius<sup><small style='font-size:8pt' title='06.06.2013'>v0.9.0</small></sup> <small>print('Hello, World!')</small></h1>
      </div>
    </div>
  </div>
</div>

<div class='container-fluid'>
  <div class='row-fluid'>
    <div id='items' class='span8 offset2'>
<h1 id='introduction'>
  <a href='#introduction' class='muted'>§</a> Предисловие
</h1>
<p class='well well-large'>Code Hardcorius — неудачная попытка изложить свои знания относительно программирования.</p>
<p>Здравствуйте. Меня зовут <a href='http://com.muna.by/people/ruliov'>Александр Рулёв</a> и я в какой-то степени программист. Хотя и не люблю называть себя таковым, т.к. на момент написания данного абзаца не имел никаких законченных и успешных проектов. Однако незаконченные проекты хоть и не приносят известности, власти и богатсва, приносят опыт и скилл.</p>
<p>Этот скилл, который я получил за около 6-8 лет моего «стажа» я и попытаюсь выразить в виде данного произведения. Вообще, я обычно веду отсчёт с 13 лет, когда получил свои первые деньги за код, однако несколько лет до этого я потратил на обучение. Полностью самостоятельное, у меня ни родители нисколько не программисты (и не учёные, не учителя), не было знакомых программистов. Даже интернета какое-то время не было. Книг тоже не было (кроме 2-3 штук).</p>
<p>Я не несу никакой ответственности за все изменения, которые могут произойти в вашей жизни в следствии прочитанного, если что. Если я вдруг напишу какую-то неправду и вы запомните это на всю жизнь — я тоже не виноват. <a href='#input-data'>Не доверяйте данным, пришедшим от клиента</a>.</p>
<p>План данной «книги» таков: разбираемся с устройством <a href='#algorhytm'>алгоритмов</a>, учимся их строить, разбираемся с <a href='#back'>базовыми понятиями</a>, начинаем погружаться в мир <a href='#concepts'>абстракций</a>, <a href='#abstract'>абстрактных типов данных</a>, узнаём про <a href='#OOProgramming'>ООП</a>, дополнительно разбираемся в понятии <a href='#architecture'>«архитектура»</a>, затронем вопросы <a href='#security'>безопасности</a>, а так же <a href='#complexity'>сложностей алгоритмов</a>.</p>
<p>Так же обращаю ваше внимание на то, что здесь я не буду ничего объяснять про код (в смысле про синтаксисы языков). Это не входит в цели данного произведения. Этим займутся, возможно, такие имена как <b>Python Hardcorius™</b>, <b>C++ Hardcorius™</b>, <b>Javascript Hardcorius™</b>. Но до этого ещё далеко.</p>
<p>Ну что ж. Попробуем.</p>
<h1 id='algorhytm'>
  <a href='#algorhytm' class='muted'>§</a> Алгоритм
</h1>
<p>Я надеюсь, что вы понимаете, что значит слово «алгоритм». Если же нет, то сделайте следующим образом. Наберите в адресной строке вашего браузера <a href='http://google.com'>http://google.com/</a>. Там в строке наберите «алгоритм», узнайте и возвращайтесь. Когда вы чего-то не знаете, но хотите узнать — всегда делайте так. И через какое-то время вы будете знать довольно много. Либо знать, как это найти.</p>
<p>Я же попытаюсь рассказать о концепциях, которых, в принципе, достаточно, чтобы построить любой алгоритм.</p>
<p>Суть понятия алгоритма в том, что у нас есть некая последовательность действий, а так же некие логические конструкции, которые позволяют нам исполнять, либо же не исполнять некоторые части данного алгоритма, что ведёт к решению нашей проблемы нужным нам образом.</p>
<p>Я не стану рисовать блок-схемы, хоть это и был бы самый простой способ это объяснить. Но я надеюсь, вы уловите суть. Или же найдёте их и посмотрите.</p>
<p><span class='text-warning'>Внимание!</span> Далее я буду прям с окопа бросать в вас код. Если вас к этому не готовили, то можете смело пропускать его и читать лишь то, что написано «нормальными» буквами. Но я надеюсь, ваше мышление способно уловить суть неизвестного вам кода.</p>
<h2 id='if'>
  <a href='#if' class='muted'>§</a> Условие
</h2>
<p>Оператор if, ветвление, условный оператор. Не важно, как называть, суть одна. Данная конструкция позволяет «отправить» выполнение алгоритма по другому пути.</p>
<p>Т.е. например, мы хотим ограничить доступ к нашей программе добросовестным людям, которые ещё не достигли 18-летнего возраста. Для этого нам нужно условие, которое будет сверять разницу между текущим годом и годом рождения человека. Этим и занимается if.</p>
<pre><code data-language='python'># encoding: utf-8

from time import gmtime

currentYear = gmtime().tm_year # Получаем текущий код
# Получаем год рождения от пользователя:
userYear = int(input('Введите год, в котором вы родились: '))

if currentYear - userYear &lt; 18: # Вот он, например
    print('Извините, но дальше идёт hardporn-раздел, вам нельзя!')
else:
    print('Нет, мы врали. Здесь ничего нет.')</code></pre>
<p>Здесь, конечно, есть множество проблем. Например, не обрабатывается ситуация, если пользователь введёт не число, год может быть неадекватным (например, в будущем или больше чем 150 лет (нежить — не наша целевая аудитория)). Но главная проблема в том, что человеку уже может быть 18, но по разнице лет ещё нет. Можно ввести погрешность в год, либо просить ещё месяц и день. Но этот пример исключительно для демонстрации сути условия, так что не суть важно.</p>
<p>Если хотите это запустить на своём компьютере, вам нужно скачать и установить <a href='http://www.python.org/download/'>Python 3</a>. Если это вам не помогло и вы всё равно не знаете как запустить... погуглите что-нибудь вроде «how to run python script». Например, там есть ссылка на <a href='http://docs.python.org/3/faq/windows'>FAQ с сайта питона</a>.</p>
<h2 id='loop'>
  <a href='#loop' class='muted'>§</a> Цикл
</h2>
<p>Суть цикла в том, чтобы организовать повторение некоторой части алгоритма до выполнения какого-то условия.</p>
<p>Если бы я мог рисовать блок-схемы, было бы легко понять, почему есть несколько разновидностей цикла и чем они отличаются друг от друга. Но, надеюсь, удастся объяснить и текстом.</p>
<h3 id='while'>
  <a href='#while' class='muted'>§</a> while
</h3>
<p>Что в переводе с английского дословно «пока». Данный вид цикла <b>сначала</b> проверяет истинность условия, и только если оно истинно выполняет часть алгоритма. Иначе переходит к другой его ветви.</p>
<p>К примеру, попросим пользователя ввести число и пока его квадрат будет меньше миллиона, будем возвозить его в квадрат и выводить результат:</p>
<pre><code data-language='python'># encoding: utf-8

# Получаем рациональное число от пользователя:
number = float(input('Введите число: '))

while number * number &lt; 1000000:
    number = number * number
    print(number)</code></pre>
<p>У данного алгоритма так же есть недостатки. Во-первых мы снова не проверяем, число ли нам вообще поступило. Во-вторых мы совершаем операцию умножения дважды, это не хорошо. В-третьих, если число находится в промежутке от -1 до 1, то этот цикл никогда не закончится, т.к. оно никогда не станет больше миллиона. Исправим это (кроме проверки на ввод числа):</p>
<pre><code data-language='python'># encoding: utf-8

# Получаем рациональное число от пользователя:
number = float(input('Введите число: '))

if abs(number) &gt; 1: # abs — функция взятия модуля от числа
    pow = number**2 # ** это оператор возведения в степень.
    while pow &lt; 1000000:
        number = pow
        print(number)
        pow = pow**2 # Следующее умножение
else:
    print('Число от -1 до 1 не подходит. Вы неудачник.')</code></pre>
<p>Отлично, теперь мы вычисляем квадрат лишь один раз в цикле. Но теперь появилась другая проблема. Мы вычисляем квадрат следующей итерации цикла. Я не вижу способа решить это кроме как сделать следующим образом:</p>
<pre><code data-language='python'># encoding: utf-8

# Получаем рациональное число от пользователя:
number = float(input('Введите число: '))

if abs(number) &gt; 1: # abs — функция взятия модуля от числа
    while True: # Да-да, цикл будет выполняться «вечно»
        pow = number**2

        if pow &lt; 1000000: # Если меньше миллиона, присваиваем
            number = pow
        else: # Иначе выполняем break, для завершения вышестоящего цикла
            break
else:
    print('Число от -1 до 1 не подходит. Вы неудачник.')</code></pre>
<p>Здесь мы создали цикл, у которого условие всегда истинно. А самое условие выхода поместили внутрь цикла. Всегда следите за тем, чтобы был какой-либо вариант выхода из цикла. Никто не любит, когда программы зависают.</p>
<h3 id='do-while'>
  <a href='#do-while' class='muted'>§</a> do while
</h3>
<p>Do-while отличается от просто while тем, когда проверяется условие. Если у while оно проверялось перед исполнением части алгоритма, то в do-while оно проверяется после. Т.е. сначала выполняются инструкции алгоритма, а затем проверяется условие. Т.е. инструкции цикла выполнятся хотя бы один раз.</p>
<h3 id='for'>
  <a href='#for' class='muted'>§</a> for
</h3>
<p>For это просто «синтаксический сахар» над while. Синтаксическим сахаром называют такие конструкции языка, которые можно привести к другим, более простым. Они вводятся для того, чтобы на языке было проще писать.</p>
<p>Выведем все целые числа от 4 до 12 (пример на <a href='http://ru.wikipedia.org/wiki/C%2B%2B'>C++</a>):</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

int main(int argc, char *argv[]) {

    // Здесь int i = 3 это создание переменной i целого типа,
    // которой мы присваиваем значение 3.
    // i++ это операция увеличения значения i на единицу
    for (int i = 3; i &lt;= 12; i++) {
        std::cout &lt;&lt; i &lt;&lt; ' ';
    }

    // Переходим на новую строку
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre>
<p>Семантика оператора for проста. Есть три части: инициализация, проверка условия, пост-действие.</p>
<ol>
  <li>Перед выполнением цикла сначала выполняются некоторые действия по инициализации, например, в данном примере мы создаём переменную, по которой будем итерировать.</li>
  <li>Затем идёт условие. У нас оно проверяет, меньше либо равна ли наша переменная i.</li>
  <li>Ну и пост-действие (сам назвал, не знаю, как оно на самом деле называется) совершается в момент, когда все инструкции из тела цикла были выполнены (т.е. в конце итерации).</li>
</ol>
<p>Когда я говорил, что это синтаксический сахар, я вот что имел в виду. Нашу программу можно переписать следующим образом:</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

int main(int argc, char *argv[]) {

    int i = 3;
    while (i &lt;= 12) {
        std::cout &lt;&lt; i &lt;&lt; ' ';

        i++;
    }

    // Переходим на новую строку
    std::cout &lt;&lt; std::endl;

    return 0;
}</code></pre>
<p>Смекаете?</p>
<h1 id='back'>
  <a href='#back' class='muted'>§</a> Фундаментальное <span class='muted'>(?)</span>
</h1>
<p>Знак вопроса здесь стоит потому, что я пока не знаю, как назвать эту часть. Здесь мы будем рассматривать базовые понятия, присущие языкам программирования.</p>
<p>Я буду приводить примеры кода, но, опять же, если вы не понимаете куда его и что — можете лишь попытаться понять, что он делает. Изучать конкретные языки программирования мы будем в самом конце, сейчас моя цель — рассказать о основных концепциях, без которых программирование практически невозможно. Но буду рад, если вы сможете установить себе IDE, либо просто компилятор языка, запустить пример, может быть что-то попробовать в том же направлении и т.д.</p>
<h2 id='variable'>
  <a href='#variable' class='muted'>§</a> Переменная
</h2>
<p>Понятие переменной является, вероятно одним из самых простых. Вы и сами наверняка знаете, что это такое. Суть такова, что мы можем «объявить» переменную, создав соответствие некоторого имени и участка памяти, где она хранится (нет-нет, это не сложно). А затем присваивать ей различные значения.</p>
<p>Например, мы можем создать переменную «имя» и записать туда «Саша». А потом в ходе выполнения программы записать «Ваня», например. Или переменную, в которую мы можем записывать числа. Или ещё чего-нибудь, что нам нужно сохранить на каком-то промежутке выполнения программы.</p>
<p>У переменной есть такое понятие как «тип». Тип определяет возможные значения, которые может принимать переменная. Есть типы, например, целых чисел, целых неотрицательных чисел, дробных, символов, строк и прочие другие.</p>
<p>При этом существует несколько подходов к типизации в языках программирования. Типизация может быть статической и динамической. Разница между этими двумя вариантами в том, что при статической типизации вы должны указать тип вручную и можете записывать туда данные только того типа, который указали. При динамической же вы можете записывать в переменную что вам вздумается.</p>
<p>Она из подходов имеют свои плюсы и минусы. С одной стороны, при статической типизации программы меньше подвержены ошибкам, т.к. компилятор может проверять, значения правильных ли типов присваиваются переменным. Но с другой стороны динамическая типизация позволяет писать код быстрее, не сильно задумываясь о типах и иногда существенно облегчать реализацию в некоторых моментах.</p>
<p>Посмотрим на идентичные примеры на C++ и на Python 3.</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

int main(int argc, char *argv[]) {
    
    int answer = 42; // Целое знаковое число
    int delta = 21;

    int resultAnswer = (answer + delta * 2) / 2;

    std::cout &lt;&lt; "Answer is: " &lt;&lt; resultAnswer &lt;&lt; std::endl;

    float money = 67.41573; // Дробное число

    std::cout &lt;&lt; "I have $" &lt;&lt; money &lt;&lt; std::endl;

}</code></pre>
<p>Как видите, в каждом случае чётко определено, целое это или дробное число.</p>
<pre><code data-language='python'>answer = 42
delta = 21

result_answer = (answer + delta * 2) / 2

print('Answer is: %s' % int(result_answer))

money = 67.41573

print('I have $%s' % money)</code></pre>
<p>В питоне же, типы определяются динамически, в момент выполнения операции присвеения значения. Поэтому, например, в переменной result_answer у нас хранится дробное число, а не целое и при выводе нам пришлось явно указать, что оно целое, чтобы не было выведено лишнее ".0", как у дробного.</p>
<h2 id='array'>
  <a href='#array' class='muted'>§</a> Массив
</h2>
<p>Массив это не более чем определённое количество переменных одного типа, объединённых под одним именем и с доступом по индексу.</p>
<p>Например, в C++ строки могут быть представлены как массив символов:</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

int main(int argc, char *argv[]) {
    
    char hello[7] = "Hello?";

    std::cout &lt;&lt; hello &lt;&lt; std::endl; // Hello?

    hello[5] = '!';

    std::cout &lt;&lt; hello &lt;&lt; std::endl; // Hello!

}</code></pre>
<p>Здесь мы создаём массив символов размером в 7 символов (в нашей строке лишь 6, один «лишний» символ нужен, чтобы хранить нуллбайт, по наличию которого язык определяет конец строки (т.к. она может быть потенциально любого размера и мы не храним её длину где-либо).</p>
<p>Мы выводим исходную строку, а затем меняем шестой символ (нумерация здесь идёт с нуля, об этом в следующей главе о указателях) на символ восклицательного знака а затем выводим строку снова.</p>
<p>Данные должны быть одного типа, потому что в памяти массив представляется как последовательность «мест» для значений переменных, а разные типы могут занимать различное пространство.</p>
<h2 id='function'>
  <a href='#function' class='muted'>§</a> Функция
</h2>
<p>Функциями в языках программирования называются такие конструкции, которые позволяют повторно использовать некоторые куски кода. Функция принимает аргументы и возвращает некое значение. Например, нам нужно найти N-ое число Фибоначчи.</p>
<pre><code data-language='python'>N = 7

prev = 0
current = 1
for i in range(N - 1):
    prevCopy = prev
    prev = current
    current += prevCopy

print(current)</code></pre>
<p>Ряд Фибоначчи начинается так: 1 1 2 3 5 8 13... Программа выше выводит 13, значит всё верно. А теперь представьте, что нам нужно найти не один раз его, а несколько. Не копировать ведь код, верно? Для этого и предназначены функции:</p>
<pre><code data-language='python'># encoding: utf-8

def fibonacci(N):
    prev = 0
    current = 1
    for i in range(N - 1):
        prevCopy = prev
        prev = current
        current += prevCopy

    return current

a = fibonacci(3)
b = fibonacci(5)
c = fibonacci(7)

print(a, b, c)</code></pre>
<p>Выводит 2 5 13. Всё сходится. Видите написано def fibonacci(N)? N в скобках это аргумент фукции. Т.е. когда в программе мы написали fibonacci(5), в блоке кода тела функции будет доступна переменная N, значение которой равно пяти. Так же в конце имеется ключевое слово return. Этот оператор берёт то, что справа от него и «возвращает». Это значит, что программа возобновит свою работу с того места, где эта фукция была вызвана а сама она как-бы «заменится» на это значение.</p>
<p>Вот, например, когда мы сделали a = fibonacci(3), начал исполняться код функции fibonacci, затем дошло до return (там у нас число 2), вернулось к строке a = fibonacci(3), но оно уже a = 2. И в итоге переменной a присвоился результат работы функции.</p>
<h3 id='recursion'>
  <a href='#recursion' class='muted'>§</a> Рекурсия
</h3>
<p>Рекурсией называется метод, когда функция вызывает саму себя. В прошлой заметке мы находили N-ое число Фибоначчи при помощи цикла. Теперь найдём при помощи рекурсии:</p>
<pre><code data-language='c++'># encoding: utf-8

def fibonacci(N):
    if N &lt;= 2:
        return 1
    else:
        return fibonacci(N - 1) + fibonacci(N - 2)

a = fibonacci(3)
b = fibonacci(5)
c = fibonacci(7)

print(a, b, c)</code></pre>
<p>Получилось несколько чуть более компактнее и проще, возможно. Дело в том, что числа Фибоначчи можно определить следующим образом:</p>
<pre>f(1) = 1
f(2) = 1
f(3) = f(2) + f(1) = 2
f(4) = f(3) + f(2) = 3
f(5) = f(4) + f(3) = 5
...</pre>
<p>Видите закономерность? Результат функции можно представить как сумму результатов функций с аргументом на единицу и на двойку меньше, чем текущий. Ну и первые два элемента определены изначально.</p>
<p>Что мы и сделали в коде. Однако этот вариант хоть и более «по-математически», он обладает существенными недостатками с решением используя циклы. Во-первых мы дважды выполняем функцию, что не эффективно, т.к. мы лишний раз пересчитываем весь ряд целиком (при этом не просто в два раза, а даже больше, потому что оно каждый раз ещё разветвляется). Во-вторых вызов функции не бесплатен, каждый вызов функции 
то создание в стеке (позже о нём) дополнительной «переменной», которая указывает на место программы, где мы вызывали эту функцию (чтобы знать, куда вернуться, когда она выполнится).</p>
<p>Впрочем, мы можем решить некоторые из этих проблем. Но всё равно, если это возможно — не используйте рекурсию там, где можно обойтись без неё, не жертвуя удобством.</p>
<h2 id='pointer'>
  <a href='#pointer' class='muted'>§</a> Указатель
</h2>
<p>Относительно сложная тема, но, надесь, мы справимся. Указатели обычно имеются лишь в «низкоуровневых» языках, где предоставлен прямой доступ к памяти. Назначение указателей, как ни странно — указывать на значение какой-либо переменной.</p>
<p>Указатель, на самом деле, это переменная специального типа, которая хранит обычно 32 или 64-битное (в зависимости от битности операционной системы) целое число, которое является адресом в памяти той переменной, на которую мы указываем.</p>
<p>Так же существуют операторы взятия адреса от переменной и оператор «разыменовывания», который позволяет по адресу получить значение переменной, которая находится по этому адресу.</p>
<p>К примеру, мы можем создать некую переменную <b>A</b> и указатель на неё <b>B</b>. Например, значение переменной <b>A</b> находится по адресу <b>1334</b> и оно равно <b>777</b>, а значение указателя находится по адресу <b>2048</b>. Т.е. в памяти по адресу <b>1334</b> хранится значение <b>777</b>. А по адресу <b>2048</b> находится значение <b>1334</b>.</p>
<p>Выглядит немного запутанно, да. Давайте посмотрим пример:</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

int main(int argc, char *argv[]) {

    int A = 777;
    int *B = &A;

    std::cout &lt;&lt; "A value: " &lt;&lt; A &lt;&lt; ". A address: " &lt;&lt; &amp;A &lt;&lt; std::endl;
    std::cout &lt;&lt; "B value: " &lt;&lt; B &lt;&lt; ". B address: " &lt;&lt; &amp;B &lt;&lt; std::endl;
    std::cout &lt;&lt; "*B value: " &lt;&lt; *B &lt;&lt; std::endl;

}</code></pre>
<p>Данная программа у меня выводит что-то вроде:</p>
<pre>A value: 777. A address: 0x7fffe4aed624
B value: 0x7fffe4aed624. B address: 0x7fffe4aed628
*B value: 777</pre>
<p>Эти большие числа и есть адреса (они в 16-ричной записи). Как вы видите, указатель просто хранит адрес переменной, на которую он указывает и позволяет получить доступ к значению по этому адресу. Обратите внимание, что при каждом запуске программы они будут различны. Это связано с тем, что система выделяет под переменные каждый раз другой кусочек памяти, потому что другие программы могли занять предыдущий между запусками, наприр.</p>
<p>Так же, если мы изменим значение A, либо *B, то значение в *B, либо в A соответственно так же изменится, потому что на самом деле оно там не хранится, а указатель лишь указывает на истинное местонахождение значения.</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

int main(int argc, char *argv[]) {

    int A = 777;
    int *B = &A;

    std::cout &lt;&lt; "A value: " &lt;&lt; A &lt;&lt; ". A address: " &lt;&lt; &amp;A &lt;&lt; std::endl;
    std::cout &lt;&lt; "*B value: " &lt;&lt; *B &lt;&lt; ". B value: " &lt;&lt; B &lt;&lt; ". B address: " &lt;&lt; &amp;B &lt;&lt; std::endl;

    A = 12;
    std::cout &lt;&lt; std::endl &lt;&lt; "A now is 12." &lt;&lt; std::endl &lt;&lt; std::endl;

    std::cout &lt;&lt; "A value: " &lt;&lt; A &lt;&lt; ". A address: " &lt;&lt; &amp;A &lt;&lt; std::endl;
    std::cout &lt;&lt; "*B value: " &lt;&lt; *B &lt;&lt; ". B value: " &lt;&lt; B &lt;&lt; ". B address: " &lt;&lt; &amp;B &lt;&lt; std::endl;

    *B = 4;
    std::cout &lt;&lt; std::endl &lt;&lt; "*B now is 4." &lt;&lt; std::endl &lt;&lt; std::endl;

    std::cout &lt;&lt; "A value: " &lt;&lt; A &lt;&lt; ". A address: " &lt;&lt; &amp;A &lt;&lt; std::endl;
    std::cout &lt;&lt; "*B value: " &lt;&lt; *B &lt;&lt; ". B value: " &lt;&lt; B &lt;&lt; ". B address: " &lt;&lt; &amp;B &lt;&lt; std::endl;

}</code></pre>
<p>Вывод данной программы получился следующим:</p>
<pre>A value: 777. A address: 0x7fffeca117c4
*B value: 777. B value: 0x7fffeca117c4. B address: 0x7fffeca117c8

A now is 12.

A value: 12. A address: 0x7fffeca117c4
*B value: 12. B value: 0x7fffeca117c4. B address: 0x7fffeca117c8

*B now is 4.

A value: 4. A address: 0x7fffeca117c4
*B value: 4. B value: 0x7fffeca117c4. B address: 0x7fffeca117c8</pre>
<p>Как видите, значение переменной меняется вместе с значением разыменованного указателя и наоборот.</p>
<p>Так же возможны более сложные варианты, вроде создания указателя на указатель. Мы можем создать указатель, который указывает на указатель. В таком случае для доступа к значению, на которое указывает указатель, на который мы указываем нужно дважды его разыменовать.</p>
<p>Смысл использования указателей и указателей на указателей я сейчас попробую объяснить. Указатели используются для трёх целей, в основном:</p>
<ul>
  <li>Выделение памяти не на стеке, а в куче (об этом позже).</li>
  <li>Массивы.</li>
  <li>Передача ссылок на значеие в функцию, чтобы она могла его изменить в процессе выполнения.</li>
</ul>
<p>Начнём с массивов, потому что мы о них хоть что-то знаем. Как я сказал, массив это определённое количество элементов одного типа, к которым есть доступ по индексу. Как это организовано. Допустим, у нас есть массив из 32-битных чисел, размером в 10 элементов. Т.е. он должен занимать 40 байт, непрерывно.</p>
<p>Переменная, через которую мы работаем с массивом и которая его представляет на самом деле является указателем на первый его элемент. И так как значение указателя (адрес, где размещается этот первый элемент) это просто число и мы знаем, сколько байт занимает каждый элемент, мы можем нехитрыми действиями вычислить адрес, по которому располагается определённый элемент массива. Давайте посмотрим пример.</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

int main(int argc, char *argv[]) {

    int array[3] = {10, 20, 30};

    std::cout &lt;&lt; array[0] &lt;&lt; ' ';
    std::cout &lt;&lt; array[1] &lt;&lt; ' ';
    std::cout &lt;&lt; array[2] &lt;&lt; std::endl;

    int *p = array;

    std::cout &lt;&lt; *(p + 0) &lt;&lt; ' ';
    std::cout &lt;&lt; *(p + 1) &lt;&lt; ' ';
    std::cout &lt;&lt; *(p + 2) &lt;&lt; std::endl;

}</code></pre>
<p>Здесь мы просто создали массив из трёх элементов: 10, 20 и 30. Вывели его. Затем создали указатель, которому присвоили значение массива (обратите внимание, что не пришлось даже адрес брать, как с обычной переменной). И вывели значение, которое получается при разыменовывании указателя плюс смещение (мы не умножали его на размер int'а потому что C++ автоматически делает это за нас и если мы прибавим к указателю, который указывает на переменную типа int, например, 15, то это будет смещение, эквивалентное 15 int'ам).</p>
<p>Относительно непонятных стеков и куч. Дело в том, что значения переменных, которые вы объявляете, хранятся в неком <a href='#stack'>стеке</a>, который находится в оперативной памяти. Программа, например, может где-то у себя внутри запоминать, сколько переменных в стеке она создала и при выходе из функции очистить столько верхних элементов стека. Либо же иметь какие-либо более совершенные методы. Но суть в том, что этот стек ограничен и не может хранить очень большое количество данных. И, например, создать массив в миллион элементов может не получиться.</p>
<p>Поэтому можно вызовом специальной функции попросить у операционной системы себе какой-то кусок оперативной памяти. Этот метод вернёт нам его адрес и мы сможем с ним работать, записывать туда что-то и так далее. И самое главное, что в стеке находится лишь значение указателя на этот наш удалённый «островок».</p>
<p>Указатели, вообще, довольно сложно понять, к тому же я вижу, что плохо объясняю. Но перейдём к последнему. Мы знаем, что функции принимают аргументы и могут работать с ними. Однако посмотрите на этот пример:</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

// Тип void значит, что функция ничего не возвращает
void addFive(int a) {
    a += 5;
}

int main(int argc, char *argv[]) {

    int a = 5;

    addFive(a);

    std::cout &lt;&lt; a &lt;&lt; std::endl;

}</code></pre>
<p>Думаете будет выведено 10? Нет. Дело в том, что в функцию передаются значения, а не «сами переменные». Т.е. в функции будет копия переменной, а не она сама. Чтобы иметь возможность изменять значение переменной нужно передать указатель на неё:</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

void addFive(int *a) {
    // Получаем доступ к значению разыменовывая указатель
    // и прибавляем к нему пятёрку
    *a += 5;
}

int main(int argc, char *argv[]) {

    int a = 5;

    addFive(&lt;a); // Берём адрес от a и передаём его в функцию

    std::cout &lt;&lt; a &lt;&lt; std::endl;

}</code></pre>
<p>Вот, результат этой программы будет уже 10. Потому что передавши адрес, нам всё равно, копия это или нет, мы можем его разыменовать и получить доступ к значению.</p>
<p>Однако представим, что у нас есть указатель и мы хотим в функции изменить на что он будет указывать. Здесь то же самое. Нам передаётся <b>значение</b> указателя, лишь копия. Чтобы изменить его, нам нужно передать в функцию... указатель на указатель. Теперь понимаете, для чего они нужны?</p>
<h2 id='struct'>
  <a href='#struct' class='muted'>§</a> Структура
</h2>
<p>Иногда вам могут потребоваться более сложные типы данных, чем просто число или массив символов. Для исполнения ваших желаний существуют структуры. Они позволяют создать свой тип, которых сможет хранить несколько переменных разных типов. Создадим какую-нибудь структуру.</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

struct Person {
    const char *firstName;
    const char *lastName;
    unsigned short age;
};

int main(int argc, char *argv[]) {

    Person ruliov;
    ruliov.firstName = "Александр";
    ruliov.lastName = "Рулёв";
    ruliov.age = 19;

    std::cout &lt;&lt; ruliov.firstName &lt;&lt; ' ' &lt;&lt; ruliov.lastName &lt;&lt; ", " &lt;&lt; ruliov.age &lt;&lt; " лет" &lt;&lt; std::endl;

}</code></pre>
<p>Как видите, в этом нет ничего сложного. Причём переменную ruliov мы даже можем передать в какую-нибудь функцию. Но в таком случае вам следует передавать её по указателю, потому что создание копии структуры является довольно дорогой операцией (больше памяти придётся скопировать), да и скорее всего вы хотите её каким-либо образом изменить.</p>
<h1 id='concepts'>
  <a href='#concepts' class='muted'>§</a> Концепции
</h1>
<p>Данная часть рассматривает довольно таки абстрактные вещи, которые вроде как не нужны для того, чтобы программировать, но здорово косвенно помогают в понимании этого всего.</p>
<h2 id='black-box'>
  <a href='#black-box' class='muted'>§</a> Чёрный ящик
</h2>
<p>Начнём с чёрного ящика. Чёрным ящиком называется некоторый объект, на который можно каким-то образом воздействовать а так же он сам может совершать какие-либо действия. Причём мы знаем, как он себя будет вести, если мы подействуем на него определённым образом.</p>
<p>Абстрактно, да. Приведу конкретный пример. Микроволновка. Это некое устройство, внутрь которого можно поместить, например, тарелку с супом, нажать несколько раз на кнопку и ждать сигнала. После достать нагретый суп, с температурой зависящей от того, какие кнопки вы нажали.</p>
<p>Причём нам, как её пользователям, совершенно не важно, как она устроена внутри. Там может быть что угодно. Может быть магнетрон, как и положено, а может быть и армия миниатюрных существ с микроволновыми пушками, которые расстреливают еду из щелей, а когда их будят а еды не дают — они гневаются.</p>
<p>Так или иначе, нас это не интересует. Нас интересует лишь то, чтобы эта железка могла нагреть нам нашу еду когда это требуется. И она это делает.</p>
<p>В этом и заключается понятие чёрного ящика. Мы не знаем как оно реализовано внутри, но знаем что нужно делать, чтобы получить то, что нам нужно.</p>
<p>Если осознать, что языки программирования, их стандартные и нестандартные библиотеки являются чёрными ящиками, предоставляют некий <a href='#interface-concept'>интерфейс</a> для взаимодействия с ними и нам по сути всё равно, как оно устроено там внутри.</p>
<p>Когда вы подходите к микроволновке, то скорее всего вы хотите разогреть что-то, а не разобрать её и посмотреть что внутри. Вот и с программированием так же. Вам просто нужно решить некоторую задачу при помощи некоторых программных средств — вы её решаете, не интересуясь, как всё устроено внутри. Даже если оно может быть устроено невероятно сложно.</p>
<p>Но когда вы имеете сводное время и желание — вы вполне можете поинтересоваться и заглянуть в недры.</p>
<h2 id='state'>
  <a href='#state' class='muted'>§</a> Состояние
</h2>
<p>Состояние — одно из свойств чёрного ящика (хотя применимо и более широко). Состояние это то, из-за чего поведение чёрного ящика может меняться от тех же воздейсвий, которые мы на него оказываем.</p>
<p>Например, раз мы уже взяли в качестве примера микроволновку (эх, нужно было брать телевизор), то посмотрите, на панели есть множество различных кнопок. Но запускает процесс лишь одна. Однако перед нажатием на неё вы можете нажать какую-нибудь другую, которая изменит внутреннее состояние и в итоге нажатие на «финальную» кнопку совершит другое действие.</p>
<p>Приведу пример с простым телевизором (да, сразу так нужно было), с которым всё никак не может разобраться дедушка. Там есть всего 4 кнопки:</p>
<ol>
  <li>Включение/выключение</li>
  <li>Вверх</li>
  <li>Вниз</li>
  <li>«Функциональная кнопка»</li>
</ol>
<p>Вот наши кнопки. Теперь рассмотрим состояния, в которых может быть телевизор. Изначально он выключен, в этом состоянии он реагирует на нажатие лишь одной кнопки — включения. Когда он включён, кнопки вверх-вниз меняют текущий канал (что так же является частью состояния, по сути). Для того, чтобы изменить громкость, нужно нажать на кнопку функциональную. Одна переведёт состояние телевизора в «изменение уровня звука» и кнопки вверх-вниз будут изменять уже громкость, а не переключать каналы. Если нажать её ещё несколько раз, то можно переключиться в режимы вроде настройки цветов и так далее, но это мы опустим, для упрощения системы. Возьмём лишь изменение цветовой гаммы.</p>
<p>Заметьте, что в зависимости от состояния, одни и те же действия (нажатия на те же кнопки) могут оказывать различный эффект на наш объект (телевизор). Построим таблицу, где столбцами будут действия, а строками текущее состояние.</p>
<table class='table'>
  <thead>
    <tr>
      <td></td>
      <th>Включение/выключение</th>
      <th>Вверх</th>
      <th>Вниз</th>
      <th>Функциональная кнопка</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <th>Выключен</th>
      <td>Включён</td>
      <td>Ничего</td>
      <td>Ничего</td>
      <td>Ничего</td>
    </tr>
    <tr>
      <th>Включён</th>
      <td>Выключен</td>
      <td>Следующий канал</td>
      <td>Предыдущий канал</td>
      <td>Настройка громкости</td>
    </tr>
    <tr>
      <th>Настройка громкости</th>
      <td>Выключен</td>
      <td>Громче</td>
      <td>Тише</td>
      <td>Настройка гаммы</td>
    </tr>
    <tr>
      <th>Настройка гаммы</th>
      <td>Выключен</td>
      <td>Ярче</td>
      <td>Темнее</td>
      <td>Включён</td>
    </tr>
  </tbody>
</table>
<p>Мне кажется, что вы поняли.</p>
<h2 id='interface-concept'>
  <a href='#interface-concept' class='muted'>§</a> Интерфейс
</h2>
<p>Когда вы поняли, что такое чёрный ящик и прочитали предыдущую заметку про состояние, будет крайне просто понять, что такое интерфейс, т.к. я уже упоминал несколько из них. Интерфейс — это способ взаимодействия с неким объектом.</p>
<p>Кнопки на телевизоре/микроволновке/другой штуковине это и есть интерфейс, через который вы взаимодействуете с устройством.</p>
<p>Интерфейс может быть представлен чем угодно. Кнопками, крутилками, рычажками, звоночком, в который можно позвонить, гонгом, в который можно ударить. Если это конечно как-то повлияет на устройство.</p>
<p>Но это относительно физических устройств. Нужно понимать, что относительно программ всё абсолютно так же. Есть «чёрные ящики», у них есть состояния, у них есть интерфейсы (в виде различных функций, например).</p>
<p>Что ж, с абстрактностью закончили, перейдём... к абстрактностям. Но на этот раз к <a href='#abstract'>абстрактным типам данных</a>.</p>
<h1 id='abstract'>
  <a href='#abstract' class='muted'>§</a> Абстрактные типы данных
</h1>
<p>Дело в том, что есть конкретные типы данных (например, <a href='#variable'>переменная</a> (указатель, по сути, это тоже переменная), <a href='#array'>массив</a>), а есть «абстрактные». Они отличаются тем, что если конкретные заданы явно, то абстрактные заданы неким паттерном использования указателей.</p>
<p>Перейдём к спискам, чтобы стало понятнее, что я хочу сказать.</p>
<h2 id='list'>
  <a href='#list' class='muted'>§</a> Список
</h2>
<p>Список — наиболее простой абстрактный тип данных. Он совсем немного похож на массив с одной стороны, но совершенно им не является.</p>
<p>И массив и список предназначены для хранения множества переменных. Однако если массив должен быть определённой длины (потому что мы предварительно должны знать, сколько памяти нужно выделить для него), то список не имеет такого недостатка, в него можно поместить хоть ни одного, хоть целую кучу элементов (пока память не закончится).</p>
<p>Хотя у списка есть другой недостаток, нельзя получить элемент по его позиции «мгновенно». Почему так происходит, рассмотрим при рассмотрении односвязного списка.</p>
<h3 id='singly-linked'>
  <a href='#singly-linked' class='muted'>§</a> Односвязный список
</h3>
<p>Итак, сейчас я попытаюсь объяснить, как устроен и для чего требуется односвязный список. Как я сказал в прошлой заметке — список может содержать произвольное количество элементов. Это достигается следующим образом: создаётся <a href='#struct'>структура</a> имеющая два поля, поле для данных и указатель типа такой структуры.</p>
<p>Изначально мы имеем лишь NULL-указатель (указатель, который указывает на нулевой байт памяти, а т.к. он занят операционной системой и заведомо не может быть занят программой, считывается, что он никуда не указывает). Это значит, что в нашем списке нет элементов. Затем, когда нам нужно добавить в него элемент, мы выделяем память под структуру элемента списка, записываем в неё данные, которые мы хотим сохранить и присваиваем нашему указателю адрес созданной структуры.</p>
<p>Теперь у нас есть указатель, указывающий на структуру с данными нашего первого элемента. Добавим ещё один элемент. Снова создаём структуру, записываем в неё данные. В указатель (который хранится в структуре) записываем значение указателя, который указывает на начало списка. И присваиваем этому указателю адрес на только что созданную структуру.</p>
<p>Немного непонятно объяснил, возможно, поясню. Чтобы добавить новый элемент в начало нашего списка мы создаём структуру, делаем так, чтобы у неё был указатель на следующую структуру (т.е. на ту, на которую в данный момент указывает наш указатель), заменяем значение указателя на адрес только что созданной структуры.</p>
<p>То есть список, по сути — это указатель на первый элемент списка и указатели на следующий элемент у каждого из них. Получается такая «цепочка» элементов. Именно поэтому для того, как я говорил, чтобы получить элемент к определённому элементу списка нам нужно «пройтись» по всем предыдущим. Потому что мы не имеем адреса конкретного элемента, всё что у нас есть — адрес первого из них. И нам нужно за эту «ниточку» вытягивать все остальные, чтобы получить тот, который нам нужен.</p>
<p>Реализую этот список на C++:</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

struct ListElement {
    int data;
    ListElement *next;
};

void addElement(ListElement **list, int x) {
    ListElement *el = new ListElement(); // Создаём структуру для нового элемента
    el-&gt;data = x; // Сохраняем данные
    el-&gt;next = *list; // Делаем чтобы новая структура указывала на старую первую
    *list = el; // Делаем первым элементом только что созданную структуру
}

int main(int argc, char *argv[]) {

    ListElement *head = NULL;

    addElement(&amp;head, 49);
    addElement(&amp;head, 30);
    addElement(&amp;head, 86);
    addElement(&amp;head, -3);
    addElement(&amp;head, 12);

    ListElement *el = head;
    while (el != NULL) {
        std::cout &lt;&lt; el-&gt;data &lt;&lt; ' ';
        el = el-&gt;next;
    }

    std::cout &lt;&lt; std::endl;

}</code></pre>
<p>Вывод у программы такой:</p>
<pre>12 -3 86 30 49</pre>
<p>Заметьте, что т.к. мы добавляем элементы в начало списка, то первым будет идти тот, который добавили последним, а последним тот, который добавляли первым.</p>
<p>Чтобы добавить элемент в конец списка мы должны пройтись по им всем, чтобы найти последний (который будет указывать на NULL), создать новую структуру и сделать так, чтобы старый последний (который мы нашли) указывал не на NULL, а на созданный элемент. Поэтому кажется логичным, что мы можем пожертвовать 4 или 8 байтами на указатель на последний элемент и не искать его каждый раз.</p>
<p>Удалять из списка элементы не сильно сложнее, чем добавлять. Нужно просто взять элемент, который следует перед тем, который мы ходим удалить и элемент после. Затем сделать так, чтобы элемент перед стал указывать на элемент после. И освободить память, занятую элементом, который мы удаляем.</p>
<h3 id='doubly-linked'>
  <a href='#doubly-linked' class='muted'>§</a> Двусвязный список
</h3>
<p>Двусвязный список отличается от односвязного лишь тем, что каждый элемент имеет ссылку так же и на предыдущий, т.е. мы можем перемещаться и в обратном направлении.</p>
<h2 id='stack'>
  <a href='#stack' class='muted'>§</a> Стек
</h2>
<p>Стек — структура данных, в которую можно помещать и удалять из неё элементы. Причём тот элемент, который мы положили последним мы достанем первым.</p>
<p>Это можно сравнить с коробкой, в которую мы складываем книги, причём мы можем ложить книги только одну на одну. Мы видим и можем достать лишь верхнюю из них. Чтобы достать последнюю — нам придётся достать все над ней.</p>
<p>Стек легко реализовать при помощи списка:</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

struct ListElement {
    int data;
    ListElement *next;
};

void addElement(ListElement **list, int x) {
    ListElement *el = new ListElement();
    el-&gt;data = x;
    el-&gt;next = *list;
    *list = el;
}

// Получает и удаляет первый элемент списка
int popElement(ListElement **list) {
    int data = (*list)-&gt;data; // Достаём данные
    ListElement *next = (*list)-&gt;next; // и указатель на следующий элемент

    delete *list; // Освобождаем память занятую первым элементом
    *list = next; // Старый следующий элемент теперь первый

    return data;
}

int main(int argc, char *argv[]) {

    ListElement *stack = NULL;

    addElement(&amp;stack, 1);
    addElement(&amp;stack, 2);

    std::cout &lt;&lt; popElement(&amp;stack) &lt;&lt; ' '; // 2

    addElement(&amp;stack, 3);

    std::cout &lt;&lt; popElement(&amp;stack) &lt;&lt; ' '; // 3
    std::cout &lt;&lt; popElement(&amp;stack) &lt;&lt; ' '; // 1

    std::cout &lt;&lt; std::endl;

}</code></pre>
<p>Вывод, как не сложно догадаться, будет — 2 3 1.</p>
<h2 id='queue'>
  <a href='#queue' class='muted'>§</a> Очередь
</h2>
<p>Очередь похожа на стек тем, что так же имеет те же две операции: добавление и удаление. Отличие её лишь в том, что она работает как очередь. Тот, кто первым в неё попал первым её и покинет. Так же легко реализуется при помощи списка, нужно лишь сохранять указатель на последний элемент, добавлять новые элементы в конец списка, а извлекать с начала.</p>
<h2 id='hashtable'>
  <a href='#hashtable' class='muted'>§</a> Хеш-таблица
</h2>
<p>Хештаблица интересна тем, что позволяет хранить множество пар ключ-значение и иметь произвольный доступ к этим парам по ключу.</p>
<p>К сожалению, я не покажу вам примеров реализации, поскольку ни разу не реализовывал её. Впрочем, я и вам бы не сильно советовал бы, разве что для собственного развития. Я лишь расскажу, как это работает.</p>
<p>Предположим, что в качестве ключа у нас выступает обычное число (пусть будет положительным). Так же предположим, что оно может быть совершенно любым (например, 4 миллиарда) и очевидно, что мы не можем себе позволить просто сделать такой огромный массив (это на примерно 4 гигабайта).</p>
<p>Поэтому нам нужен какой-то способ, чтобы «ужать» значения в более компактный промежуток, чтобы мы могли создать массив такого размера. Этот способ предоставляют хеш-функции (поэтому хеш-таблица и называется хеш-таблицей). Такие функции берут большие числа, либо же какие-либо бинарные данные (что, по сути, просто очень большие числа) и возвращают более адекватные числа, заключённые в определённом промежутке.</p>
<p>Самой простой хеш-функцией является такая функция, которая просто берёт N первых или последних бит числа, например.</p>
<p>Изначально мы создаём массив какого-то размера, элементами которого являются пустые списки (эти списки называются слотами или вёдрами (buckets)). Когда мы хотим поместить элемент в хештаблицу, мы берём хеш от его ключа, получаем соответствующее ведро и помещаем в начало или конец структуру, в которой хранится ключ и значение.</p>
<p>Когда мы хотим достать элемент по ключу, мы опять берём хеш от ключа, получаем ведро, проходимся по этому списку, находим элемент, ключ которого равен тому, который мы достаём и возвращаем значение. Мы не можем сохранять лишь значение по той причине, что хеш-функции подвержены коллизиям. Сами подумайте, если мы можем ужать более просторный промежуток значений в промежуток покороче, то если мы сопоставим каждому значению из короткого промежутка некое значение (одно) из большого, то в большом останется ещё много, у которых нет пары. А на самом деле у них есть отображение в один из элементов короткого. Поэтому несколько элементов могут быть сопоставлены одному. Поэтому нам нужно хранить их все.</p>
<p>С ростом количества элементов в хештаблице будет расти количество коллизий и скорость доступа к произвольному элементу будет падать (точнее к тем, у которых больше коллизий), поэтому когда элементов становится больше, чем нужно, размер таблицы увеличивают и выбирают хеш-функцию на более просторный диапазон значений (например, берут на один бит больше). Это довольно затратная операция, т.к. нужно обойти все элементы, содержащиеся в таблице, взять от них хеш и поместить в новую.</p>
<h3 id='hashmap'>
  <a href='#hashmap' class='muted'>§</a> HashMap
</h3>
<p>HashMap — это просто синоним хеш-таблицы. Он позволяет добавлять и удалять некоторые значения по ключу.</p>
<h3 id='hashset'>
  <a href='#hashset' class='muted'>§</a> HashSet
</h3>
<p>HashSet (set — множество) — реализация множества при помощи хеш-таблицы. У элементов такой хеш-таблицы нет значений, хранятся лишь ключи. Т.е. мы можем быстро проверить, есть ли в множестве некоторый элемент или нет.</p>
<h2 id='tree'>
  <a href='#tree' class='muted'>§</a> Дерево
</h2>
<p>Вариаций данного типа данных существует довольно много и так же существует множество алгоритмов, которые используют деревья, либо производят над ними какие-либо действия. Дерево называется деревом потому, что каждый элемент дерева представляет из себя такую структуру, которая имеет, в отличии от списка несколько указателей на элементы дерева.</p>
<p>Бинарное дерево, например, имеет два указателя. И, например, может быть использовано для организации поиска по множеству каких-либо элементов. Мы можем создать такое дерево, у которого первый его узел будет средним по медиане элементом из этого множества. Затем сравнивать его значение с тем, которое мы хотим найти, если оно меньше — спускаемся на «левый» узел, иначе на правый. И так далее, пока не найдём.</p>
<p>Искать элемент, если он находится в дереве поиска намного быстрее, чем искать элемент в списке, когда нам нужно обойти все элементы по порядку.</p>
<p>Если вас интересует тема деревьев — вы без проблем найдёте информацию о них в интернете. Здесь я вам помочь не смогу, т.к. почти никогда их не использовал в явном виде.</p>
<h1 id='paradigms'>
  <a href='#paradigms' class='muted'>§</a> Парадигмы
</h1>
<p>В программировании существует такое понятие как парадигмы. Это понятие довольно абстрактное, я не могу его чётко сформулировать, приведу примеры.</p>
<p>Изначально, как я понимаю, существовали большущие «схемы», размером в комнату и больше. И программирование сводилось к тому, чтобы переключать некие тумблеры в определённых местах, либо соединять разные контакты шнурами (на самом деле я вообще ничего не знаю об этом и просто предполагаю). Такое программирование мы можем назвать шнуро-ориентированным, например.</p>
<p>Через много лет появились микросхемы, представляющие из себя <a href='#black-box'>чёрные ящики</a>, у которых есть входы и выходы (ножки), на которые следует в определённом порядке подавать ток, чтобы записать туда некий <a href='#algorhytm'>алгоритм</a> и затем тоже в некотором порядке можно подавать ток на другие ножки, чтобы вводить туда данные и алгоритм выполнялся. Ну и так же на некоторых ножках может появляться ток, что мы должны обрабатывать и тоже что-то делать.</p>
<p>Ну и люди сделали устройства, которые позволяют брать некий текст и преобразовывать в эту необходимую последовательность подачи электричества на ножки микросхем. Сначала этот текст представлял «сырой» код, называемый машинным. Т.е. у каждой схемы существовала документация, какие числа (числа могут быть представлены в виде последовательности подачи электричества, или более хитрыми способами) будучи переданными в микросхему что будут делать.</p>
<p>В машинном коде было сложно программировать, поскольку он был похож просто на мешанину цифр (ну и букв, если записано в шеснадцатеричной форме). Поэтому изобрели ассемблер (множество их), который представлял лишь мнемонические синонимы для машинных команд. Т.е. например, команда <b>mov</b>, которая вроде как записывает значение с одного адреса в другой будет преобразована в какое-нибудь число.</p>
<p>На этом этапе возможно существовали какие-либо парадигмы, но код был в виде большого длинного списка различных команд. На этом программировать так же было затруднительно.</p>
<p>Придумали различные языки, которые являлись более «высокими», чем ассемблер, плюс позволяли компилировать программы написанные на этих языках в разные языки ассемблера, чтобы запускаться на различных устройствах. В этом момент появилось структурно-ориентированное программирование. Появились функции и процедуры (в ассемблере они так же по сути были, но «не так явно»).</p>
<p>Теперь код преставлял из себя функции, процедуры, принимающие различные аргументы и возвращающие результат. Каждая из функций/процедур могла быть использована множество раз в различных проектах, но с этим всё равно были проблемы. Кто-то сказал, что когда кода становится очень много, функций становится ещё больше и начинаются проблемы, потому что... потому что.</p>
<h2 id='OOP'>
  <a href='#OOP' class='muted'>§</a> ООП
</h2>
<p>И сказал человек: «Всё есть объект!». И появилось объектно-ориентированное программирование. Каждый из объектов представлял какой-то объект «реального мира», имел свойства этого объекта, имел методы, чтобы их изменять и получать состояние объекта. Появилось наследование, полиморфизм, начали следить за инкапсуляцией.</p>
<p>Но по сути, ничего не изменилось, поэтому обещанного рая не наступило. Хотя все надеялись.</p>
<p>В данный момент большая часть всего программирования — ООП. Когда вы разберётесь с ним, вы поймёте, что ООП не заключено в рамки каких-либо «объектно-ориентированных» языков вроде Java, C# и прочих. Писать «с объектами» можно на любом языке, хоть на ассемблере. Объекты не в коде, объекты у вас в голове.</p>
<h2 id='FP'>
  <a href='#FP' class='muted'>§</a> Функциональное программирование
</h2>
<p>Функциональное программирование пришло откуда-то из математики. Дело в том, что все виды программирования, что я назвал выше были императивными (даже парадигма такая существует — императивное программирование). Это значит, что программа имеет глобальное состояние и вызовы тех же функций, иногда с теми же аргументами могли выполняться иначе и выдавать разные результаты. Это не понравилось математикам, у которых мир был более строг и если функция выполняется с одинаковыми аргументами — она должна выдавать тот же результат.</p>
<p>В этом и заключается суть функционального программирования. Оно лишено глобального состояния. Оно не изменяет <a href='#state'>состояние</a> объектов. Мы можем лишь взять старую версию объекта, применить на неё какие-либо изменения и получить новую, с новым состоянием.</p>
<p>Разница лишь в том, что императивный код зависит от состояния и один и тот же код может вести себя по-разному, а функциональный будет работать абсолютно так же. В этом и заключается прелесть. Вы можете тестировать отдельные куски не боясь за то, что в каком-либо другом окружении оно будет работать иначе.</p>
<h1 id='OOProgramming'>
  <a href='#OOProgramming' class='muted'>§</a> Объектно-ориентированное программирование
</h1>
<p>Окей, начнём разбираться с ООП. На это требуется некоторое время, сначала иногда непонятно, зачем вводить все эти штуки. Но тем ни менее все они были введены, потому что были (и сейчас тоже) нужны.</p>
<p>Иногда буква П обозначает «подход», а не «программирование». Не сильно вижу разницы, на самом деле.</p>
<h2 id='object'>
  <a href='#object' class='muted'>§</a> Объект
</h2>
<p><i>«Всё есть объект»</i></p>
<p>Объект — очевидно, основная компонента ООП. Объект, по сути, представляет некий <a href='#black-box'>чёрный ящик</a>, однако чаще всего его реализуете именно вы, поэтому, скорее белый.</p>
<p>Объекты имеют поля и методы. Поля могут хранить некие данные (это просто такие переменные, доступные в методах объекта и уникальные для каждого объекта). Методы же это обычные функции, которые так же принимают аргументы и так же возвращают результат. Только в дополнение к этому имеют доступ к полям объекта.</p>
<p>Объекты создаются вызовом конструктора класса. Конструктор класса представляет из себя функцию, которая ведёт себя так же, как и метод.</p>
<p>Пример класса рационального числа на C++ (дроби с целым числителем и натуральным знаменателем) с методами сложения, вычитания, умножения и деления:</p>
<pre><code data-language='c++'>#include &lt;iostream&gt;

using namespace std;

class Rational {
  private:
    int numerator, denominator;
  public:
    Rational(int numerator) {
        this-&gt;numerator = numerator;
        denominator = 1;
    }
    Rational(int numerator, int denominator) {
        this-&gt;numerator = numerator;
        this-&gt;denominator = denominator;

        this-&gt;reduce();
    }

    Rational add(const Rational &amp;other) const {
        return Rational(this-&gt;numerator * other.denominator +
                            other.numerator * this-&gt;denominator,
                        this-&gt;denominator * other.denominator);
    }
    Rational subtract(const Rational &amp;other) const {
        return Rational(this-&gt;numerator * other.denominator -
                            other.numerator * this-&gt;denominator,
                        this-&gt;denominator * other.denominator);
    }

    Rational multiply(const Rational &amp;other) const {
        Rational result(this-&gt;numerator * other.numerator,
                        this-&gt;denominator * other.denominator);

        result.reduce();

        return result;
        
    }
    Rational divide(const Rational &amp;other) const {
        return this-&gt;multiply(other.inverse());
    }

    Rational inverse() const {
        return Rational(this-&gt;denominator, this-&gt;numerator);
    }

    // Друг для перегрузки оператора &lt;&lt;
    friend ostream &amp;operator&lt;&lt;(ostream&amp;, const Rational&amp;);
  private:
    // Сокращение дроби
    void reduce() {
        int gcd = Rational::GCD(this-&gt;numerator, this-&gt;denominator);
        this-&gt;numerator /= gcd;
        this-&gt;denominator /= gcd;
    }

    // Нахождение НОД двух чисел
    static int GCD(int a, int b) {
        int min, max;
        if (a &lt; b) {
            min = a;
            max = b;
        } else {
            min = b;
            max = a;
        }

        while (true) {
            int n = max / min;
            max -= min * n;

            if (max == 0) return min;

            int temp = max;
            max = min;
            min = temp;
        }
    }
};

// Перегружаем оператор &lt;&lt; для нашего класса
ostream &amp;operator&lt;&lt;(ostream &amp;os, const Rational &amp;rational)
{
    os &lt;&lt; '(' &lt;&lt; rational.numerator &lt;&lt; " / " &lt;&lt; rational.denominator &lt;&lt; ')';
    return os;
}

int main(int argc, char *argv[]) {

    Rational a(2);
    Rational b(3);
    Rational c(1, 4);
    Rational d(1, 3);
    Rational e(2, 3);
    Rational f(9, 5);

    cout &lt;&lt; c &lt;&lt; " + " &lt;&lt; d &lt;&lt; " = " &lt;&lt; c.add(d) &lt;&lt; endl;
    cout &lt;&lt; d &lt;&lt; " - " &lt;&lt; c &lt;&lt; " = " &lt;&lt; d.subtract(c) &lt;&lt; endl;
    cout &lt;&lt; e &lt;&lt; " * " &lt;&lt; f &lt;&lt; " = " &lt;&lt; e.multiply(f) &lt;&lt; endl;
    cout &lt;&lt; a &lt;&lt; " / " &lt;&lt; b &lt;&lt; " = " &lt;&lt; a.divide(b) &lt;&lt; endl;

}</code></pre>
<p>Если скомпилировать и запустить этот код, мы получим следующий вывод:</p>
<pre>(1 / 4) + (1 / 3) = (7 / 12)
(1 / 3) - (1 / 4) = (1 / 12)
(2 / 3) * (9 / 5) = (6 / 5)
(2 / 1) / (3 / 1) = (2 / 3)</pre>
<p>Как видите, операции над дробями выглядят так, будто бы работают корректно.</p>
<h2 id='class'>
  <a href='#class' class='muted'>§</a> Класс
</h2>
<p>Класс — это описание структуры объекта. Вы описываете некий класс, а затем можете создавать множество объектов, которые являются экземплярами этого класса. Каждый из объектов будет иметь те же поля и методы, которые вы описали в классе. Конечно же, у полей разных объектов будут свои значения, а не общие для всех.</p>
<p>Классы имеют конструкторы, вызов которого создаёт экземпляр класса. Конструктор класса является, по сути, обычной функцией, принимающей некие аргументы и устанавливающий в зависимости от них значения полей объекта.</p>
<p>Так же класс может иметь деструктор, который проведёт некие «освободительные» действия, которые освободят использованные объектом ресурсы.</p>
<p>Класс можно рассматривать как <a href='#struct'>структуру</a> с полями, плюс методы, которые можно вызывать и которые будут тем или иным образом иметь доступ к этой структуре (в разных языках по-разному, в C++, например, через <i>this</i>, в питоне через <i>self</i>, который явно передаётся аргументом в метод.</p><p>Однако в дополнение к этому добавляются такие возможности как наследование и полиморфизм.</p>
<h2 id='inheritance'>
  <a href='#inheritance' class='muted'>§</a> Наследование
</h2>
<p>Наследование — механизм, который используется для того, чтобы создать более «частный» случай некого класса. При наследовании мы создаём новый класс, у которого мы можем изменить поведение методов и/или добавить новых методов/полей.</p>
<h2 id='object-interface'>
  <a href='#object-interface' class='muted'>§</a> Интерфейс
</h2>
<p>Интерфейс в ООП это механизм, который, основным образом реализует полиморфизм. Интерфейс представляет из себя просто список методов, которые должен иметь класс, который реализует данный интерфейс.</p>
<p>Т.е. мы можем, например, создать интерфейс <i>мяу</i> и сказать, что класс, который захочет реализовать интерфейс <i>мяу</i> должен иметь метод <b>meow</b>, возвращающий строку.</p>
<p>Для того, чтобы узнать, для чего нужны интерфейсы — прошу перейти дальше, к понятию полиморфизма.</p>
<h2 id='polymorphism'>
  <a href='#polymorphism' class='muted'>§</a> Полиморфизм
</h2>
<p>Полиморфизм является наиболее выдающейся частью ООП. У одного человека на рабочем столе была заметка, что «полиморфизм — это многообразие форм». Впрочем... так и есть.</p>
<p>Смысл этого мнообразия в том, что мы можем объявить переменную для объекта типом «выше», чем реальный тип объекта, который мы в неё запишем. А так же мы можем объявлять переменные для объекта типом интерфейса, а затем присваивать ей ссылки на объекты, которые реализуют данный интерфейс.</p>
<p>Что это даёт? Например, у нас есть тот самый интерфейс <i>мяу</i>. Мы можем создать переменную типа <i>мяу</i> и присвоить ей любой объект, класс которого имеет метод <b>meow</b>. После этого мы можем вызывать этот метод. Причём будет выполняться метод того класса, объект которого на самом деле хранится в этой переменной.</p>
<p>А теперь больше. Это так же работает и с функциями. Т.е. мы можем создавать обобщённые функции, которые могут совершать действия над объектами классов о которых ничего не знает (они могут быть написаны, например, после того, как была написана эта функция), но при этом знает, что у этого объекта есть некоторые методы, которые она может вызывать.</p>
<h1 id='architecture'>
  <a href='#architecture' class='muted'>§</a> Архитектура
</h1>
<p>В разработке ПО (программного обеспечения) есть такое понятие как <i>архитектура</i>. Архитектура определяет структуру, благодаря которой будут связаны различные компоненты системы. Архитектура может быть как плохой, так и хорошей. При хорошей архитектуре вашего проекта в него легко добавить новые «фичи», удалить старые, исправить какие-либо баги без проблем и возможности сломать остальные части системы. При плохой же архитектуре написание кода в проекте станет для вас адом и вы будете проклинать тот день, когда решили стать программистом.</p>
<p>Хорошая архитектура строится на модульности, использовании паттернов, обобщённости (посредством <a href='#polymorphism'>полиморфизма</a>), хорошей инкапсуляцией «сложного кода».</p>
<p>Хотя то что я перечислил — это то, что нашёл я и большинство современных программистов. Возможно через какое-то время вы, либо кто-то ещё скажет, что модульность никому не нужна и придумает что-то, что сейчас непостижимо для сознания современных программистов.</p>
<p>Но мы будем рассматривать именно её.</p>
<h2 id='incapsulation'>
  <a href='#incapsulation' class='muted'>§</a> Инкапсуляция
</h2>
<p>Поговаривают, что инкапсуляция — это один из принципов ООП. Но я считаю, что это не так. Инкапсуляция существовала при всех подходах, хоть они и могли походить на объектно-ориентированный. Инкапсуляция — принцип/подход/решение, которое говорит, что ваши объекты должны иметь предельно простой для использования <a href='#interface-concept'>интерфейс</a>, за которым может <a hreef='#black-box'>скрываться</a> сколь угодно сложная логика.</p>
<p>Под этим я имею в виду то, что если вы разобрались в чём-то невообразимо сложном и хотите дать возможность использовать это другим людям без необходимости снова разбираться в этой области — вы должны создать такой объект, который мог бы использовать любой человек без каких-либо проблем.</p>
<p>Например, возьмём какое-нибудь страшное слово, вроде <b>преобразования Фурье</b> (два слова, окей). Понятия не имею, что это такое, но если оно мне понадобиться, я должен иметь возможность взять объект, и просто передать коэфициенты в его метод и получить результат.</p>
<p>Без необходимости полдня разбираться, какие поля объекту я должен задать, в какой последовательности и с какими интервалами, зависящими от фазы луны вызвать набор методов, передать пять объектов разных типов с горсткой аргументов и так же хитро настроенными полями.</p>
<p>Интерфейс должен быть простой.</p>
<h2 id='patterns'>
  <a href='#patterns' class='muted'>§</a> Паттерны
</h2>
<p>Если перевести слово «паттерн» на русский, может получиться что-то вроде «узор», или около того. Паттерны — типовые структуры, которые вы можете использовать для построения свой системы.</p>
<p>Существует огромное множество паттернов проектирования в данный момент, а так же тьма примеров их реализации на огромном количестве языков. Однако я хотел бы, чтобы вы поняли, что вы не обязаны использовать их во что бы то ни стало. Вы должны просто их знать, чтобы «расширить свой кругозор» и уметь делать сложную систему простой.</p>
<p>Это сложно объяснить. Если вы зациклитесь на том, чтобы везде совать паттерны, которые там на самом деле не нужны — вы не будете учиться ничему новому и из этого ничего не выйдет. Возможно в вашем случае есть куда более подходящий вариант, но вы по прежнему используете варианты, которым вас учили.</p>
<p>Я не говорю, что это плохо. Я лишь говорю, что если вы не будете развиваться — вы станете роботом, который лишь выполняет свои задачи. И когда появятся более совершенные роботы — они вас с лёгкостью вытеснят и вы будете никому не нужны.</p>
<p>Прошу меня извинить за философию.</p>
<p>Как я сказал, паттернов существует крайне много, поэтому сложно удержаться от того, чтобы включить целую дюжину их сюда. Но это произведение не о паттернах, вы можете найти их в более предназначенном для этого места. Поэтому я напишу лишь о нескольких, которые наиболее сильно на меня повлияли.</p>
<h3 id='dependency-injection'>
  <a href='#dependency-injection' class='muted'>§</a> Dependency injection
</h3>
<p>По-русски это звучит как «внедрение зависимости». Суть в том, что когда мы создаём объекты — после создания мы «внедряем» в него объекты, которые реализуют эти самые «зависимости».</p>
<p>Реализуется это крайне просто: классы имеют поля, типа <a href='#object-interface'>интерфейс</a>, а так методы, которые позволяют присваивать им ссылки на объекты, реализующие эти интерфейсы.</p>
<p>Выгода следует из того, что мы можем иметь различные реализации каких-то частей системы и передавая их в объекты, которые используют эти части (т.е. зависимы от них) можем менять поведение системы изменяя только модули, которые мы хотим изменить и никакие другие больше.</p>
<p>Например, у нас есть объект для сбора неких событий, которые происходят (ведение лога). Мы можем выделить зависимость <i>«хранилище»</i> или около того. Сделаем для неё интерфейс <b>IStorage</b>, имеющий метод <b>store</b>, принимающий строку.</p>
<p>А затем мы можем создать две реализации этого интерфейса. Один класс будет выводить пришедшую строку на экран, а второй записывать в файл.</p>
<p>Так же добавим классу нашего логгера метод <b>setStorage</b> принимающий объект реализующий <b>IStorage</b> и присвоим его какому-нибудь полю. Когда событие происходит — преобразуем его в строку и вызываем метод <b>store</b> объекта, который записан в этом поле. В зависимости от того, экземпляр какого класса мы «внедрили» в наш логгер он будет или выводить строку на экран или записывать её в файл.</p>
<p>Это и есть внедрение зависимостей.</p>
<p>Мы можем создать какой-либо конфиг, в котором можно выбрать, нужно писать в файл или выводить на экран. И в зависимости от него создавать соответсвующий объект и передавать его в логгер. И, например, при разработке выводить на экран, потому что так проще за этим наблюдать, а в продакшене — писать в файл, чтобы можно было посмотреть потом историю за прошлый день, к примеру.</p>
<h3 id='pubsub'>
  <a href='#pubsub' class='muted'>§</a> PubSub
</h3>
<p>Publisher-Subscriber — тоже что-то около паттерна. Он применяется для уменьшения связности кода.</p>
<p>В данном паттерне существует три сущности — событие, publisher (возможно по-русски это будет «издатель», будем называть его источником событий) и подписчик. Событие имеет имя и свойства. Подписчики могут «подписаться» на событие по имени, т.е. попросить источник уведомить их, когда это событие произойдёт.</p>
<p>Это может быть реализовано следующим образом, например. Создаётся массив, ключами которого являются имена событий, а элементами — списки функций. Когда кто-то подписывается на событие, указатель на функцию, которую нужно вызвать при наступлении события, помещается в соответствующий список. И когда событие происходит — источник проходит по списку и вызывает все функции, передавая в них свойства события.</p>
<h3 id='mvc'>
  <a href='#mvc' class='muted'>§</a> MVC
</h3>
<p>MVC (Model-View-Controller) — шаблон проектирования, который целиком изменил мои взгляды на программирование и сильно поспособствовал переходу на следующий уровень. Данный шаблон используется для разделения «бизнес-логики» и хранения данных (Model), представления результата (View), взаимодействия с системой (Controller).</p>
<p>Модель отвечает за работу с непосредственно данными и выполнением каких-либо манипуляций над ними. Например, мы делаем шахматы. Здесь модель реализует шахматную логику, хранит положение фигур на доске, имеет методы для совершения ходов, которые изменяют это положение.</p>
<p>Представление (View) занимается исключительно... представлением результатов работы системы. В нашем примере представлением будет часть, отвечающая за GUI (Graphical User Interface — графический интерфейс пользователя) наших шахмат. Т.е. у нас есть объект, который может показывать доску, показывать по запросу фигуры на нужных клетках.</p>
<p>Контроллер — это то, что является мостом между моделью и представлением а так же обрабатывает какую-то логику, связанную с действиями пользователя. Например, наше представление является <a href='#pubsub'>источником событий</a> и при попытке выбора фигуры, которой хочет походить пользователь генерирует событие <b>select</b>. Контроллер подписывается на это событие и когда пользователь выбирает фигуру — спрашивает у модели, можно ли походить этой фигурой или нет. Если можно — вызывает, например, метод представления <b>selected</b>. Который рисует на экране подсветку выбранной фигуры, к примеру.</p>
<p>Таким образом отображение игры не имеет никакого влияния на логику и правила игры. Плюс в теории мы можем заменить любую из этих частей для получение иного поведения системы. К примеру, мы можем сделать другое представление, которое выводит то, что происходит на консоль, а не рисует красивые окошки. И мы получим консольные шахматы, не переписывая логику их работы.</p>
<p>Мы можем заменить модель шахмат на другую, которая, например, будет иметь другие правила (вдруг нам захочется чтобы кони прыгали через две клетки, а не одну, а пешки могли ходить назад). При этом не затрагивая логику ходов и отображением (заменив представление на консольное — получим шахматы с иными правилами в консольном режиме).</p>
<p>Контроллер так же можем заменить. К примеру, на такой, который при ходе оппонента не передаёт снова управление представлению (т.е. получается игра за одним компьютером), а отправляет на своих ходах данные по Интернету, принимает ответ и совершает ход. Т.е. получаем уже сетевые шахматы. Заменяя модель/представление можем изменить правила или вариант отображения.</p>
<p>Если бы мы писали всё монолитно — у нас были бы проблемы и пришлось бы переписывать практически всю программу, а не лишь часть, которую мы хотим подвергнуть изменениям.</p>
<h1 id='security'>
  <a href='#security' class='muted'>§</a> Безопасность
</h1>
<p>При обучении программированию есть одна проблема. Иногда бывает, что автор показывает такие примеры, которые будучи использованы в реальности, при определённых обстоятельствах могут вести себя совершенно не так, как хотел программист. И люди их используют в своих решениях. Затем приходят люди с определёнными способностями и без проблем получают доступ к тому, к чему у них не должно быть доступа. Или всё ломают.</p>
<p>Поэтому важно понимать, что ты делаешь и к чему это может привести.</p>
<p>Простейшим примером может быть SQL-запрос. SQL-запрос это просто строка, которая передаётся базе данных, чтобы она что-то сделала. В нём могут быть некие данные, в том числе те, которые пришли от пользователя. Ушлый пользователь может так составить свои данные, чтобы при вставке в ваш запрос он совершил не тот запрос, который вы изначально написали, а тот, который нужен пользователю. Что может привести к чтению не тех данных/модификации/удалению.</p>
<h2 id='input-data'>
  <a href='#input-data' class='muted'>§</a> Входные данные
</h2>
<p>В прошлом параграфе я привёл пример с SQL-запросом. Чтобы избежать этого, просто никогда не верьте данным клиента. Что бы он вам не передал, всегда проверяйте, точно ли оно то, что вы ожидаете.</p>
<p>Так же требуется фильтровать и экранировать строки, если вы хотите поместить их куда-либо ещё. К примеру, если вы помещаете что-то пришедшее от пользоваля в тот же SQL-запрос, вам нужно заменить все символы, которые могут оказать на него влияние на их экранированные версии (например, кавычку ' нужно заменить на \', косую черту \ на две косых черты \\ и так далее). Но ради котов, не делайте этого самостоятельно, если не уверены. Возможно в вашем языке уже реализована функция или библиотека для этих целей.</p>
<p>Ещё примеры. Если вы вставляете текст от пользователя (например, комментарий) в HTML, чтобы показать его пользователям — вам нужно быть уверенным, что если пользователь сам введёт HTML — это не окажет влияния на страницу и не сделает ничего плохого. Пользователь может, например, встроить вредоносный скрипт и делать что угодно. Нужно избегать таких ситуаций и фильтровать данные.</p>
<h1 id='complexity'>
  <a href='#complexity' class='muted'>§</a> Сложность алгоритма
</h1>
<p>Предположим, что вы умеете создавать алгоритмы. Однако хочу вас огорчить. Не все алгоритмы, которые в теории решают проблему хороши на практике. Есть понятие вычислительной сложности алгоритма.</p>
<p>В математике есть «O» большое, которое является верхней границей скорости роста некой функции. Мы будем использовать его для ограничения скорости роста «количества» вычислительных операций.</p>
<p>Рассмотрим различные «сложности» для того, чтобы понять, что это такое.</p>
<p>Например, ваш алгоритм принимает два числа и складывает их. Если записать этот алгоритм в виде кода и скомпилировать его, это будет какое-то количество команд ассемблера. Но там не будет циклов, поэтому наша программа будет выполнена за этих несколько операций и завершится. Предположим, что для этого нам нужно лишь 3 операции. Т.е. мы можем ограничить сверху выполнение нашей программы тремя операциями, вот так: O(3). Однако при обозначении сложности количество операций может отличаться между разными компиляторами/ассемблерами/компьютерами. Поэтому O(3) умножается на константу C, которая означает «коэфициент конкретности» (сам название придумал, не запоминайте), который может быть разным и мы его не знаем. Чуть дальше об этом.</p>
<p>И суть такова, что мы можем вынести константу из-под O и «поглотить» её нашей виртуальной константой C (она ведь всё равно нам неизвестная и может изменяться, какая разница, как она будет меняться?). В итоге получается, что O(3) = O(1). Это значит, что наша программа выполнится за константное время. На одном компьютере это будут мили/микро/пикосекунды, на другом, например, это может быть час (например, выполняются какие-нибудь другие программы и планировщик просто не даёт времени нашему коду).</p>
<p>Теперь возьмём другой случай. У нас есть список длины N и мы проходимся по нему два раза и применяем на каждый его элемент каких-то 5 операций. Т.е. у нас будет O(2 * 5 * N), верно? Однако 10 является константой и может быть убрано, в итоге получается O(N). Что значит, что при размере входных данных (в данном случае длине списка) равным N наша программа выполнится за линейное время. И если прибавить ещё несколько элементов в список — то и время увеличится на константу умноженную на количество добавленных элементов.</p>
<p>Перейдём ещё к более крутым сложностям. Теперь сделаем вложенный цикл, в котором будем проходиться по элементам списка (опять же длиной в N), во внешнем цикле так же будем проходиться по ним же. Т.е. для каждого элемента из списка мы будем получать все остальные и его самого. Здесь наше O будет равно O(N^2). И смотрите. Если мы добавим несколько элементов — время увеличится уже не линейно, а примерно квадратично.</p>
<p>А теперь предположим, что одна часть программы у нас имеет линейную сложность, а другая квадратичную. Получается O(N + N^2). Однако тут действует хитрое «правило». Если мы устремим N к бесконечности, то N будет расти намного медленнее, чем N^2 и практически не будет оказывать влияния на итоговое время. Поэтому мы можем отбросить его. Так, O(N + N^2) = O(N^2).</p>
<p>Для того, чтобы рассчитывать сложность своих алгоритмов необходим опыт, но простые случаи можно легко видеть. Если вы проходитесь по чему-то один раз — это O(N), если два раза — всё равно O(N). Но если вы сделали три вложенных цикла — это уже O(N^3).</p>
<p>Так же существуют и другие классы сложностей, вроде O(N^3), O(2^N), O(log N), O(N log N).</p>
<p>Для чего это нужно? Смотрите. Допустим, вы написали сортировку таким образом, что каждый элемент проверяете с каждым. Это получается O(N^2). А Вася написал сортировку, которая имеет O(N log N). Т.е. N умножить на логарифм (не суть важно основание) N. И при N → ∞, ваше N^2 будет выглядеть... медленно, по сравнению с N log N. Потому что N log N растёт куда медленнее. Если не верите — нарисуйте график того и другого. А время — деньги. При увеличении данных вам придётся покупать куда больше ресурсов, чем Васе, хотя его алгоритм выполняет ту же задачу, что и ваш. Только лучше.</p>
<h1 id='end'>
  <a href='#end' class='muted'>§</a> Заключение
</h1>
<p>Вот вы и дочитали до конца (либо просто промотали, не знаю). В данный момент написана лишь малая часть того, что должно быть написано, поэтому ждите, или прочитайте об этом в другом месте.</p>
<p>Так же, если вы нашли какую-либо нестыковку, пожалуйста, уведомите меня об этом. Мои контакты можно найти на <a href='http://com.muna.by/people/ruliov'>страничке про меня</a>.</p>
<p>Ну и если вам кажется, что я где-то написал что-то непонятно, неполно, либо вообще не покрыл какую-либо область, можете тоже сказать, постараюсь исправить.</p>
<p>Удачи!</p>

    </div>
  </div>

  <div class='row-fluid text-center' style='margin-top: 10em'>
    <p><small>Разработано в <a href='http://com.muna.by/landing/project?code' style='color:#8E1816'>Коммуне</a></small></p>
  </div>
</div>

</body>
</html>
